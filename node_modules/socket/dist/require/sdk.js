'use strict';

function _socketInterop(e) {
  let c = 0
  for (const k in e ?? {}) {
    c = c === 0 && k === 'default' ? 1 : 0
    if (!c && k !== '__esModule') break
  }
  return c ? e.default : e
}

var colors = _socketInterop(require('yoctocolors-cjs'));
var vendor = require('./vendor.js');
var hpagent = _socketInterop(require('hpagent'));
var prompts = require('@socketsecurity/registry/lib/prompts');
var strings = require('@socketsecurity/registry/lib/strings');
var sdk = require('@socketsecurity/sdk');
var constants = require('./constants.js');
var fs = require('node:fs');
var os = require('node:os');
var path = require('node:path');
var yoctoSpinner = require('@socketregistry/yocto-spinner');

class AuthError extends Error {}
class InputError extends Error {
  constructor(message, body) {
    super(message);
    this.body = body;
  }
}

// From the 'log-symbols' module
const unicodeLogSymbols = {
  __proto__: null,
  info: colors.blue('ℹ'),
  success: colors.green('✔'),
  warning: colors.yellow('⚠'),
  error: colors.red('✖')
};

// From the 'log-symbols' module
const fallbackLogSymbols = {
  __proto__: null,
  info: colors.blue('i'),
  success: colors.green('√'),
  warning: colors.yellow('‼'),
  error: colors.red('×')
};

// From the 'log-symbols' module
const logSymbols = vendor.isUnicodeSupported() ? unicodeLogSymbols : fallbackLogSymbols;
const markdownLogSymbols = {
  __proto__: null,
  info: ':information_source:',
  error: ':stop_sign:',
  success: ':white_check_mark:',
  warning: ':warning:'
};
class ColorOrMarkdown {
  constructor(useMarkdown) {
    this.useMarkdown = !!useMarkdown;
  }
  header(text, level = 1) {
    return this.useMarkdown ? `\n${''.padStart(level, '#')} ${text}\n` : colors.underline(`\n${level === 1 ? colors.bold(text) : text}\n`);
  }
  bold(text) {
    return this.useMarkdown ? `**${text}**` : colors.bold(`${text}`);
  }
  italic(text) {
    return this.useMarkdown ? `_${text}_` : colors.italic(`${text}`);
  }
  hyperlink(text, url, {
    fallback = true,
    fallbackToUrl
  } = {}) {
    if (!url) return text;
    return this.useMarkdown ? `[${text}](${url})` : vendor.terminalLink(text, url, {
      fallback: fallbackToUrl ? (_text, url) => url : fallback
    });
  }
  list(items) {
    const indentedContent = items.map(item => this.indent(item).trimStart());
    return this.useMarkdown ? `* ${indentedContent.join('\n* ')}\n` : `${indentedContent.join('\n')}\n`;
  }
  get logSymbols() {
    return this.useMarkdown ? markdownLogSymbols : logSymbols;
  }
  indent(text, level = 1) {
    const indent = ''.padStart(level * 2, ' ');
    return indent + text.split('\n').join('\n' + indent);
  }
  json(value) {
    return this.useMarkdown ? '```json\n' + JSON.stringify(value) + '\n```' : JSON.stringify(value);
  }
}

function createDebugLogger(printDebugLogs) {
  return printDebugLogs ? (...params) => console.error(logSymbols.info, ...params) : () => {};
}
function isErrnoException(value) {
  if (!(value instanceof Error)) {
    return false;
  }
  return value.code !== undefined;
}
function stringJoinWithSeparateFinalSeparator(list, separator = ' and ') {
  const values = list.filter(value => !!value);
  if (values.length < 2) {
    return values[0] || '';
  }
  const finalValue = values.pop();
  return values.join(', ') + separator + finalValue;
}

let dataHome = process.platform === 'win32' ? process.env['LOCALAPPDATA'] : process.env['XDG_DATA_HOME'];
if (!dataHome) {
  if (process.platform === 'win32') throw new Error('missing %LOCALAPPDATA%');
  const home = os.homedir();
  dataHome = path.join(home, ...(process.platform === 'darwin' ? ['Library', 'Application Support'] : ['.local', 'share']));
}
const settingsPath = path.join(dataHome, 'socket', 'settings');
let settings = {};
if (fs.existsSync(settingsPath)) {
  const raw = fs.readFileSync(settingsPath, 'utf8');
  try {
    settings = JSON.parse(Buffer.from(raw, 'base64').toString());
  } catch {
    yoctoSpinner().warning(`Failed to parse settings at ${settingsPath}`);
  }
} else {
  fs.mkdirSync(path.dirname(settingsPath), {
    recursive: true
  });
}
function getSetting(key) {
  return settings[key];
}
let pendingSave = false;
function updateSetting(key, value) {
  settings[key] = value;
  if (!pendingSave) {
    pendingSave = true;
    process.nextTick(() => {
      pendingSave = false;
      fs.writeFileSync(settingsPath, Buffer.from(JSON.stringify(settings)).toString('base64'));
    });
  }
}

const {
  rootPkgJsonPath
} = constants;

// This API key should be stored globally for the duration of the CLI execution.
let defaultKey;
function getDefaultKey() {
  const key = process.env['SOCKET_SECURITY_API_KEY'] || getSetting('apiKey') || defaultKey;
  defaultKey = strings.isNonEmptyString(key) ? key : undefined;
  return defaultKey;
}

// The API server that should be used for operations.
function getDefaultAPIBaseUrl() {
  const baseUrl = process.env['SOCKET_SECURITY_API_BASE_URL'] || getSetting('apiBaseUrl');
  return strings.isNonEmptyString(baseUrl) ? baseUrl : undefined;
}

// The API server that should be used for operations.
function getDefaultHTTPProxy() {
  const apiProxy = process.env['SOCKET_SECURITY_API_PROXY'] || getSetting('apiProxy');
  return strings.isNonEmptyString(apiProxy) ? apiProxy : undefined;
}
async function setupSdk(apiKey = getDefaultKey(), apiBaseUrl = getDefaultAPIBaseUrl(), proxy = getDefaultHTTPProxy()) {
  if (typeof apiKey !== 'string' && vendor.isInteractive()) {
    apiKey = await prompts.password({
      message: 'Enter your Socket.dev API key (not saved, use socket login to persist)'
    });
    defaultKey = apiKey;
  }
  if (!apiKey) {
    throw new AuthError('You need to provide an API key');
  }
  let agent;
  if (proxy) {
    agent = {
      http: new hpagent.HttpProxyAgent({
        proxy
      }),
      https: new hpagent.HttpsProxyAgent({
        proxy
      })
    };
  }
  const sdkOptions = {
    agent,
    baseUrl: apiBaseUrl,
    userAgent: sdk.createUserAgentFromPkgJson(require(rootPkgJsonPath))
  };
  return new sdk.SocketSdk(apiKey || '', sdkOptions);
}

exports.AuthError = AuthError;
exports.ColorOrMarkdown = ColorOrMarkdown;
exports.InputError = InputError;
exports.createDebugLogger = createDebugLogger;
exports.getDefaultKey = getDefaultKey;
exports.getSetting = getSetting;
exports.isErrnoException = isErrnoException;
exports.logSymbols = logSymbols;
exports.setupSdk = setupSdk;
exports.stringJoinWithSeparateFinalSeparator = stringJoinWithSeparateFinalSeparator;
exports.updateSetting = updateSetting;
