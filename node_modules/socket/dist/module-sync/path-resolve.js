'use strict';

function _socketInterop(e) {
  let c = 0
  for (const k in e ?? {}) {
    c = c === 0 && k === 'default' ? 1 : 0
    if (!c && k !== '__esModule') break
  }
  return c ? e.default : e
}

var fs = require('node:fs');
var path = require('node:path');
var ignore = _socketInterop(require('ignore'));
var micromatch = _socketInterop(require('micromatch'));
var tinyglobby = _socketInterop(require('tinyglobby'));
var which = _socketInterop(require('which'));
var constants = require('./constants.js');

const ignoredDirs = [
// Taken from ignore-by-default:
// https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js
'.git',
// Git repository files, see <https://git-scm.com/>
'.log',
// Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
'.nyc_output',
// Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
'.sass-cache',
// Cache folder for node-sass, see <https://github.com/sass/node-sass>
'.yarn',
// Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
'bower_components',
// Where Bower packages are installed, see <http://bower.io/>
'coverage',
// Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
'node_modules',
// Where Node modules are installed, see <https://nodejs.org/>
// Taken from globby:
// https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16
'flow-typed'];
const ignoredDirPatterns = ignoredDirs.map(i => `**/${i}`);
function directoryPatterns() {
  return [...ignoredDirPatterns];
}

const {
  NPM,
  shadowBinPath
} = constants;
async function filterGlobResultToSupportedFiles(entries, supportedFiles) {
  const patterns = ['golang', NPM, 'pypi'].reduce((r, n) => {
    const supported = supportedFiles[n];
    r.push(...(supported ? Object.values(supported).map(p => `**/${p.pattern}`) : []));
    return r;
  }, []);
  return entries.filter(p => micromatch.some(p, patterns));
}
async function globWithGitIgnore(patterns, options) {
  const {
    cwd = process.cwd(),
    socketConfig,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const projectIgnorePaths = socketConfig?.projectIgnorePaths;
  const ignoreFiles = await tinyglobby.glob(['**/.gitignore'], {
    absolute: true,
    cwd,
    expandDirectories: true
  });
  const ignores = [...directoryPatterns(), ...(Array.isArray(projectIgnorePaths) ? ignoreFileLinesToGlobPatterns(projectIgnorePaths, path.join(cwd, '.gitignore'), cwd) : []), ...(await Promise.all(ignoreFiles.map(async filepath => ignoreFileToGlobPatterns(await fs.promises.readFile(filepath, 'utf8'), filepath, cwd)))).flat()];
  const hasNegatedPattern = ignores.some(p => p.charCodeAt(0) === 33 /*'!'*/);
  const globOptions = {
    absolute: true,
    cwd,
    expandDirectories: false,
    ignore: hasNegatedPattern ? [] : ignores,
    ...additionalOptions
  };
  const result = await tinyglobby.glob(patterns, globOptions);
  if (!hasNegatedPattern) {
    return result;
  }
  const {
    absolute
  } = globOptions;
  const filtered = ignore().add(ignores).filter(absolute ? result.map(p => path.relative(cwd, p)) : result);
  return absolute ? filtered.map(p => path.resolve(cwd, p)) : filtered;
}
function ignoreFileLinesToGlobPatterns(lines, filepath, cwd) {
  const base = path.relative(cwd, path.dirname(filepath)).replace(/\\/g, '/');
  const patterns = [];
  for (let i = 0, {
      length
    } = lines; i < length; i += 1) {
    const pattern = lines[i].trim();
    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {
      patterns.push(ignorePatternToMinimatch(pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/ ? `!${path.posix.join(base, pattern.slice(1))}` : path.posix.join(base, pattern)));
    }
  }
  return patterns;
}
function ignoreFileToGlobPatterns(content, filepath, cwd) {
  return ignoreFileLinesToGlobPatterns(content.split(/\r?\n/), filepath, cwd);
}

// Based on `@eslint/compat` convertIgnorePatternToMinimatch.
// Apache v2.0 licensed
// Copyright Nicholas C. Zakas
// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28
function ignorePatternToMinimatch(pattern) {
  const isNegated = pattern.startsWith('!');
  const negatedPrefix = isNegated ? '!' : '';
  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd();
  // Special cases.
  if (patternToTest === '' || patternToTest === '**' || patternToTest === '/**' || patternToTest === '**') {
    return `${negatedPrefix}${patternToTest}`;
  }
  const firstIndexOfSlash = patternToTest.indexOf('/');
  const matchEverywherePrefix = firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1 ? '**/' : '';
  const patternWithoutLeadingSlash = firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest;
  // Escape `{` and `(` because in gitignore patterns they are just
  // literal characters without any specific syntactic meaning,
  // while in minimatch patterns they can form brace expansion or extglob syntax.
  //
  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.
  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.
  // Minimatch pattern `src/\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.
  const escapedPatternWithoutLeadingSlash = patternWithoutLeadingSlash.replaceAll(/(?=((?:\\.|[^{(])*))\1([{(])/guy, '$1\\$2');
  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : '';
  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`;
}
function pathsToPatterns(paths) {
  return paths.map(p => p === '.' ? '**/*' : p);
}
function findRoot(filepath) {
  let curPath = filepath;
  while (true) {
    if (path.basename(curPath) === NPM) {
      return curPath;
    }
    const parent = path.dirname(curPath);
    if (parent === curPath) {
      return undefined;
    }
    curPath = parent;
  }
}
async function findBinPathDetails(binName) {
  let shadowIndex = -1;
  const bins = (await which(binName, {
    all: true,
    nothrow: true
  })) ?? [];
  const binPath = bins.find((binPath, i) => {
    // Skip our bin directory if it's in the front.
    if (fs.realpathSync(path.dirname(binPath)) === shadowBinPath) {
      shadowIndex = i;
      return false;
    }
    return true;
  });
  return {
    name: binName,
    path: binPath,
    shadowed: shadowIndex !== -1
  };
}
async function getPackageFiles(cwd, inputPaths, config, supportedFiles, debugLog = () => {}) {
  debugLog(`Globbed resolving ${inputPaths.length} paths:`, inputPaths);

  // TODO: Does not support `~/` paths
  const entries = await globWithGitIgnore(pathsToPatterns(inputPaths), {
    cwd,
    socketConfig: config
  });
  debugLog(`Globbed resolved ${inputPaths.length} paths to ${entries.length} paths:`, entries);
  const packageFiles = await filterGlobResultToSupportedFiles(entries, supportedFiles);
  debugLog(`Mapped ${entries.length} entries to ${packageFiles.length} files:`, packageFiles);
  return packageFiles;
}
async function getPackageFilesFullScans(cwd, inputPaths, supportedFiles, debugLog = () => {}) {
  debugLog(`Globbed resolving ${inputPaths.length} paths:`, inputPaths);

  // TODO: Does not support `~/` paths
  const entries = await globWithGitIgnore(pathsToPatterns(inputPaths), {
    cwd
  });
  debugLog(`Globbed resolved ${inputPaths.length} paths to ${entries.length} paths:`, entries);
  const packageFiles = await filterGlobResultToSupportedFiles(entries, supportedFiles);
  debugLog(`Mapped ${entries.length} entries to ${packageFiles.length} files:`, packageFiles);
  return packageFiles;
}

exports.findBinPathDetails = findBinPathDetails;
exports.findRoot = findRoot;
exports.getPackageFiles = getPackageFiles;
exports.getPackageFilesFullScans = getPackageFilesFullScans;
