#!/usr/bin/env node
'use strict';

function _socketInterop(e) {
  let c = 0
  for (const k in e ?? {}) {
    c = c === 0 && k === 'default' ? 1 : 0
    if (!c && k !== '__esModule') break
  }
  return c ? e.default : e
}

var node_url = require('node:url');
var ponyCause = _socketInterop(require('pony-cause'));
var updateNotifier = _socketInterop(require('tiny-updater'));
var colors = _socketInterop(require('yoctocolors-cjs'));
var fs = require('node:fs');
var path = require('node:path');
var yargsParse = _socketInterop(require('yargs-parser'));
var npm$1 = require('@socketsecurity/registry/lib/npm');
var words = require('@socketsecurity/registry/lib/words');
var constants = require('./constants.js');
var meow = _socketInterop(require('meow'));
var yoctoSpinner = require('@socketregistry/yocto-spinner');
var sdk = require('./sdk.js');
var prompts = require('@socketsecurity/registry/lib/prompts');
var isInteractive = _socketInterop(require('is-interactive'));
var terminalLink = _socketInterop(require('terminal-link'));
var fs$1 = require('node:fs/promises');
var spawn = _socketInterop(require('@npmcli/promise-spawn'));
var npa = _socketInterop(require('npm-package-arg'));
var semver = _socketInterop(require('semver'));
var tinyglobby = _socketInterop(require('tinyglobby'));
var yaml = _socketInterop(require('yaml'));
var registry = require('@socketsecurity/registry');
var objects = require('@socketsecurity/registry/lib/objects');
var packages = require('@socketsecurity/registry/lib/packages');
var promises = require('@socketsecurity/registry/lib/promises');
var regexps = require('@socketsecurity/registry/lib/regexps');
var strings = require('@socketsecurity/registry/lib/strings');
var browserslist = _socketInterop(require('browserslist'));
var which = _socketInterop(require('which'));
var hyrious__bun_lockb = require('@socketregistry/hyrious__bun.lockb');
var pathResolve = require('./path-resolve.js');
var betterAjvErrors = _socketInterop(require('@apideck/better-ajv-errors'));
var config = require('@socketsecurity/config');
var homedir = require('node:os');
var readline = require('node:readline');
var node_process = require('node:process');
var readline$1 = require('node:readline/promises');
var open = _socketInterop(require('open'));
var chalkTable = _socketInterop(require('chalk-table'));
var ScreenWidget = _socketInterop(require('blessed/lib/widgets/screen'));
var BarChart = _socketInterop(require('blessed-contrib/lib/widget/charts/bar'));
var GridLayout = _socketInterop(require('blessed-contrib/lib/layout/grid'));
var LineChart = _socketInterop(require('blessed-contrib/lib/widget/charts/line'));
var util = require('node:util');
var TableWidget = _socketInterop(require('blessed-contrib/lib/widget/table'));

const {
  NPM: NPM$4,
  PNPM: PNPM$2,
  cdxgenBinPath,
  synpBinPath
} = constants;
const {
  SBOM_SIGN_ALGORITHM,
  // Algorithm. Example: RS512
  SBOM_SIGN_PRIVATE_KEY,
  // Location to the RSA private key
  SBOM_SIGN_PUBLIC_KEY // Optional. Location to the RSA public key
} = process.env;
const toLower = arg => arg.toLowerCase();
const arrayToLower = arg => arg.map(toLower);
const nodejsPlatformTypes = new Set(['javascript', 'js', 'nodejs', NPM$4, PNPM$2, 'ts', 'tsx', 'typescript']);
const yargsConfig = {
  configuration: {
    'camel-case-expansion': false,
    'strip-aliased': true,
    'parse-numbers': false,
    'populate--': true,
    'unknown-options-as-args': true
  },
  coerce: {
    author: arrayToLower,
    filter: arrayToLower,
    only: arrayToLower,
    profile: toLower,
    standard: arrayToLower,
    type: toLower
  },
  default: {
    //author: ['OWASP Foundation'],
    //'auto-compositions': true,
    //babel: true,
    //evidence: false,
    //'include-crypto': false,
    //'include-formulation': false,

    // Default 'install-deps' to `false` and 'lifecycle' to 'pre-build' to
    // sidestep arbitrary code execution during a cdxgen scan.
    // https://github.com/CycloneDX/cdxgen/issues/1328
    'install-deps': false,
    lifecycle: 'pre-build',
    //output: 'bom.json',
    //profile: 'generic',
    //'project-version': '',
    //recurse: true,
    //'server-host': '127.0.0.1',
    //'server-port': '9090',
    //'spec-version': '1.5',
    type: 'js'
    //validate: true,
  },
  alias: {
    help: ['h'],
    output: ['o'],
    print: ['p'],
    recurse: ['r'],
    'resolve-class': ['c'],
    type: ['t'],
    version: ['v']
  },
  array: [{
    key: 'author',
    type: 'string'
  }, {
    key: 'exclude',
    type: 'string'
  }, {
    key: 'filter',
    type: 'string'
  }, {
    key: 'only',
    type: 'string'
  }, {
    key: 'standard',
    type: 'string'
  }],
  boolean: ['auto-compositions', 'babel', 'deep', 'evidence', 'fail-on-error', 'generate-key-and-sign', 'help', 'include-formulation', 'include-crypto', 'install-deps', 'print', 'required-only', 'server', 'validate', 'version'],
  string: ['api-key', 'lifecycle', 'output', 'parent-project-id', 'profile', 'project-group', 'project-name', 'project-version', 'project-id', 'server-host', 'server-port', 'server-url', 'spec-version']
};
function argvToArray(argv) {
  if (argv['help']) return ['--help'];
  const result = [];
  for (const {
    0: key,
    1: value
  } of Object.entries(argv)) {
    if (key === '_' || key === '--') continue;
    if (key === 'babel' || key === 'install-deps' || key === 'validate') {
      // cdxgen documents no-babel, no-install-deps, and no-validate flags so
      // use them when relevant.
      result.push(`--${value ? key : `no-${key}`}`);
    } else if (value === true) {
      result.push(`--${key}`);
    } else if (typeof value === 'string') {
      result.push(`--${key}`, String(value));
    } else if (Array.isArray(value)) {
      result.push(`--${key}`, ...value.map(String));
    }
  }
  if (argv['--']) {
    result.push('--', ...argv['--']);
  }
  return result;
}
const cdxgen = {
  description: 'Create an SBOM with CycloneDX generator (cdxgen)',
  async run(argv_) {
    const yargv = {
      ...yargsParse(argv_, yargsConfig)
    };
    const unknown = yargv._;
    const {
      length: unknownLength
    } = unknown;
    if (unknownLength) {
      console.error(`Unknown ${words.pluralize('argument', unknownLength)}: ${yargv._.join(', ')}`);
      process.exitCode = 1;
      return;
    }
    let cleanupPackageLock = false;
    if (yargv.type !== 'yarn' && nodejsPlatformTypes.has(yargv.type) && fs.existsSync('./yarn.lock')) {
      if (fs.existsSync('./package-lock.json')) {
        yargv.type = NPM$4;
      } else {
        // Use synp to create a package-lock.json from the yarn.lock,
        // based on the node_modules folder, for a more accurate SBOM.
        try {
          await npm$1.runBin(await fs.promises.realpath(synpBinPath), ['--source-file', './yarn.lock']);
          yargv.type = NPM$4;
          cleanupPackageLock = true;
        } catch {}
      }
    }
    if (yargv.output === undefined) {
      yargv.output = 'socket-cdx.json';
    }
    await npm$1.runBin(await fs.promises.realpath(cdxgenBinPath), argvToArray(yargv), {
      env: {
        NODE_ENV: '',
        SBOM_SIGN_ALGORITHM,
        SBOM_SIGN_PRIVATE_KEY,
        SBOM_SIGN_PUBLIC_KEY
      },
      stdio: 'inherit'
    });
    if (cleanupPackageLock) {
      try {
        await fs.promises.rm('./package-lock.json');
      } catch {}
    }
    const fullOutputPath = path.join(process.cwd(), yargv.output);
    if (fs.existsSync(fullOutputPath)) {
      console.log(colors.cyanBright(`${yargv.output} created!`));
    }
  }
};

const commonFlags = {
  help: {
    type: 'boolean',
    default: false,
    shortFlag: 'h',
    description: 'Print this help.'
  }
};
const commandFlags = {
  enable: {
    type: 'boolean',
    default: false,
    description: 'Enables the Socket npm/npx wrapper'
  },
  disable: {
    type: 'boolean',
    default: false,
    description: 'Disables the Socket npm/npx wrapper'
  }
};
const outputFlags = {
  json: {
    type: 'boolean',
    shortFlag: 'j',
    default: false,
    description: 'Output result as json'
  },
  markdown: {
    type: 'boolean',
    shortFlag: 'm',
    default: false,
    description: 'Output result as markdown'
  }
};
const validationFlags = {
  all: {
    type: 'boolean',
    default: false,
    description: 'Include all issues'
  },
  strict: {
    type: 'boolean',
    default: false,
    description: 'Exits with an error code if any matching issues are found'
  }
};

const {
  API_V0_URL
} = constants;
function handleUnsuccessfulApiResponse(_name, result, spinner) {
  // SocketSdkErrorType['error'] is not typed.
  const resultErrorMessage = result.error?.message;
  const message = typeof resultErrorMessage === 'string' ? resultErrorMessage : 'No error message returned';
  if (result.status === 401 || result.status === 403) {
    spinner.stop();
    throw new sdk.AuthError(message);
  }
  spinner.error(`${colors.bgRed(colors.white('API returned an error:'))} ${message}`);
  process.exit(1);
}
async function handleApiCall(value, description) {
  let result;
  try {
    result = await value;
  } catch (cause) {
    throw new ponyCause.ErrorWithCause(`Failed ${description}`, {
      cause
    });
  }
  return result;
}
async function handleAPIError(code) {
  if (code === 400) {
    return 'One of the options passed might be incorrect.';
  } else if (code === 403) {
    return 'You might be trying to access an organization that is not linked to the API key you are logged in with.';
  }
}
async function queryAPI(path, apiKey) {
  return await fetch(`${API_V0_URL}/${path}`, {
    method: 'GET',
    headers: {
      Authorization: `Basic ${btoa(`${apiKey}:${apiKey}`)}`
    }
  });
}

function objectSome(obj) {
  for (const key in obj) {
    if (obj[key]) {
      return true;
    }
  }
  return false;
}
function pick(input, keys) {
  const result = {};
  for (const key of keys) {
    result[key] = input[key];
  }
  return result;
}

const SEVERITIES_BY_ORDER = ['critical', 'high', 'middle', 'low'];
function getDesiredSeverities(lowestToInclude) {
  const result = [];
  for (const severity of SEVERITIES_BY_ORDER) {
    result.push(severity);
    if (severity === lowestToInclude) {
      break;
    }
  }
  return result;
}
function formatSeverityCount(severityCount) {
  const summary = [];
  for (const severity of SEVERITIES_BY_ORDER) {
    if (severityCount[severity]) {
      summary.push(`${severityCount[severity]} ${severity}`);
    }
  }
  return sdk.stringJoinWithSeparateFinalSeparator(summary);
}
function getSeverityCount(issues, lowestToInclude) {
  const severityCount = pick({
    low: 0,
    middle: 0,
    high: 0,
    critical: 0
  }, getDesiredSeverities(lowestToInclude));
  for (const issue of issues) {
    const value = issue.value;
    if (!value) {
      continue;
    }
    if (severityCount[value.severity] !== undefined) {
      severityCount[value.severity] += 1;
    }
  }
  return severityCount;
}

function printFlagList(list, indent, {
  keyPrefix = '--',
  padName
} = {}) {
  return printHelpList({
    ...list
  }, indent, {
    keyPrefix,
    padName
  });
}
function printHelpList(list, indent, {
  keyPrefix = '',
  padName = 18
} = {}) {
  let result = '';
  const names = Object.keys(list).sort();
  for (const name of names) {
    const rawDescription = list[name];
    const description = (typeof rawDescription === 'object' ? rawDescription.description : rawDescription) || '';
    result += ''.padEnd(indent) + (keyPrefix + name).padEnd(padName) + description + '\n';
  }
  return result.trim();
}

const {
  SOCKET_PUBLIC_API_KEY: SOCKET_PUBLIC_API_KEY$1
} = constants;
const info = {
  description: 'Look up info regarding a package',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' info';
    const commandContext = setupCommand$m(name, info.description, argv, importMeta);
    if (commandContext) {
      const spinnerText = commandContext.pkgVersion === 'latest' ? `Looking up data for the latest version of ${commandContext.pkgName}` : `Looking up data for version ${commandContext.pkgVersion} of ${commandContext.pkgName}`;
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      const packageData = await fetchPackageData(commandContext.pkgName, commandContext.pkgVersion, commandContext, spinner);
      if (packageData) {
        formatPackageDataOutput(packageData, {
          name,
          ...commandContext
        }, spinner);
      }
    }
  }
};

// Internal functions

function setupCommand$m(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <name>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} webtorrent
      $ ${name} webtorrent@1.9.1
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  if (cli.input.length > 1) {
    throw new sdk.InputError('Only one package lookup supported at once');
  }
  const {
    0: rawPkgName = ''
  } = cli.input;
  let showHelp = cli.flags['help'];
  if (!rawPkgName) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const versionSeparator = rawPkgName.lastIndexOf('@');
  const pkgName = versionSeparator < 1 ? rawPkgName : rawPkgName.slice(0, versionSeparator);
  const pkgVersion = versionSeparator < 1 ? 'latest' : rawPkgName.slice(versionSeparator + 1);
  return {
    includeAllIssues: cli.flags['all'],
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    pkgName,
    pkgVersion,
    strict: cli.flags['strict']
  };
}
async function fetchPackageData(pkgName, pkgVersion, {
  includeAllIssues
}, spinner) {
  const socketSdk = await sdk.setupSdk(sdk.getDefaultKey() ?? SOCKET_PUBLIC_API_KEY$1);
  const result = await handleApiCall(socketSdk.getIssuesByNPMPackage(pkgName, pkgVersion), 'looking up package');
  const scoreResult = await handleApiCall(socketSdk.getScoreByNPMPackage(pkgName, pkgVersion), 'looking up package score');
  if (result.success === false) {
    return handleUnsuccessfulApiResponse('getIssuesByNPMPackage', result, spinner);
  }
  if (scoreResult.success === false) {
    return handleUnsuccessfulApiResponse('getScoreByNPMPackage', scoreResult, spinner);
  }
  const severityCount = getSeverityCount(result.data, includeAllIssues ? undefined : 'high');
  return {
    data: result.data,
    severityCount,
    score: scoreResult.data
  };
}
function formatPackageDataOutput({
  data,
  score,
  severityCount
}, {
  name,
  outputJson,
  outputMarkdown,
  pkgName,
  pkgVersion,
  strict
}, spinner) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
  } else {
    console.log('\nPackage report card:');
    const scoreResult = {
      'Supply Chain Risk': Math.floor(score.supplyChainRisk.score * 100),
      Maintenance: Math.floor(score.maintenance.score * 100),
      Quality: Math.floor(score.quality.score * 100),
      Vulnerabilities: Math.floor(score.vulnerability.score * 100),
      License: Math.floor(score.license.score * 100)
    };
    Object.entries(scoreResult).map(score => console.log(`- ${score[0]}: ${formatScore(score[1])}`));
    console.log('\n');
    if (objectSome(severityCount)) {
      spinner[strict ? 'error' : 'success'](`Package has these issues: ${formatSeverityCount(severityCount)}`);
      formatPackageIssuesDetails(data, outputMarkdown);
    } else {
      spinner.success('Package has no issues');
    }
    const format = new sdk.ColorOrMarkdown(!!outputMarkdown);
    const url = `https://socket.dev/npm/package/${pkgName}/overview/${pkgVersion}`;
    console.log('\n');
    if (pkgVersion === 'latest') {
      console.log(`Detailed info on socket.dev: ${format.hyperlink(`${pkgName}`, url, {
        fallbackToUrl: true
      })}`);
    } else {
      console.log(`Detailed info on socket.dev: ${format.hyperlink(`${pkgName} v${pkgVersion}`, url, {
        fallbackToUrl: true
      })}`);
    }
    if (!outputMarkdown) {
      console.log(colors.dim(`\nOr rerun ${colors.italic(name)} using the ${colors.italic('--json')} flag to get full JSON output`));
    }
  }
  if (strict && objectSome(severityCount)) {
    process.exit(1);
  }
}
function formatPackageIssuesDetails(packageData, outputMarkdown) {
  const issueDetails = packageData.filter(d => d.value?.severity === 'high' || d.value?.severity === 'critical');
  const uniqueIssues = issueDetails.reduce((acc, issue) => {
    const {
      type
    } = issue;
    if (type) {
      if (acc[type] === undefined) {
        acc[type] = {
          label: issue.value?.label,
          count: 1
        };
      } else {
        acc[type].count += 1;
      }
    }
    return acc;
  }, {});
  const format = new sdk.ColorOrMarkdown(!!outputMarkdown);
  for (const issue of Object.keys(uniqueIssues)) {
    const issueWithLink = format.hyperlink(`${uniqueIssues[issue]?.label}`, `https://socket.dev/npm/issue/${issue}`, {
      fallbackToUrl: true
    });
    if (uniqueIssues[issue]?.count === 1) {
      console.log(`- ${issueWithLink}`);
    } else {
      console.log(`- ${issueWithLink}: ${uniqueIssues[issue]?.count}`);
    }
  }
}
function formatScore(score) {
  if (score > 80) {
    return colors.green(`${score}`);
  } else if (score < 80 && score > 60) {
    return colors.yellow(`${score}`);
  }
  return colors.red(`${score}`);
}

const {
  SOCKET_PUBLIC_API_KEY
} = constants;
const description$5 = 'Socket API login';
const flags = {
  apiBaseUrl: {
    type: 'string',
    description: 'API server to connect to for login'
  },
  apiProxy: {
    type: 'string',
    description: 'Proxy to use when making connection to API server'
  }
};
function nonNullish(value) {
  return value !== null && value !== undefined;
}
const login = {
  description: description$5,
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} login`;
    const cli = meow(`
      Usage
        $ ${name}

      Logs into the Socket API by prompting for an API key

      Options
        ${printFlagList({
      'api-base-url': flags['apiBaseUrl'].description,
      'api-proxy': flags['apiProxy'].description
    }, 8)}

      Examples
        $ ${name}
    `, {
      argv,
      description: description$5,
      importMeta,
      flags
    });
    let showHelp = cli.flags['help'];
    if (cli.input.length) {
      showHelp = true;
    }
    if (showHelp) {
      cli.showHelp();
      return;
    }
    if (!isInteractive()) {
      throw new sdk.InputError('Cannot prompt for credentials in a non-interactive shell');
    }
    const apiKey = (await prompts.password({
      message: `Enter your ${terminalLink('Socket.dev API key', 'https://docs.socket.dev/docs/api-keys')} (leave blank for a public key)`
    })) || SOCKET_PUBLIC_API_KEY;
    let apiBaseUrl = cli.flags['apiBaseUrl'];
    apiBaseUrl ??= sdk.getSetting('apiBaseUrl') ?? undefined;
    let apiProxy = cli.flags['apiProxy'];
    apiProxy ??= sdk.getSetting('apiProxy') ?? undefined;
    const spinner = yoctoSpinner({
      text: 'Verifying API key...'
    }).start();
    let orgs;
    try {
      const sdk$1 = await sdk.setupSdk(apiKey, apiBaseUrl, apiProxy);
      const result = await sdk$1.getOrganizations();
      if (!result.success) {
        throw new sdk.AuthError();
      }
      orgs = result.data;
      spinner.success('API key verified');
    } catch {
      spinner.error('Invalid API key');
      return;
    }
    const enforcedChoices = Object.values(orgs.organizations).filter(nonNullish).filter(org => org.plan === 'enterprise').map(org => ({
      name: org.name,
      value: org.id
    }));
    let enforcedOrgs = [];
    if (enforcedChoices.length > 1) {
      const id = await prompts.select({
        message: "Which organization's policies should Socket enforce system-wide?",
        choices: enforcedChoices.concat({
          name: 'None',
          value: '',
          description: 'Pick "None" if this is a personal device'
        })
      });
      if (id) {
        enforcedOrgs = [id];
      }
    } else if (enforcedChoices.length) {
      const confirmOrg = await prompts.confirm({
        message: `Should Socket enforce ${enforcedChoices[0]?.name}'s security policies system-wide?`,
        default: true
      });
      if (confirmOrg) {
        const existing = enforcedChoices[0];
        if (existing) {
          enforcedOrgs = [existing.value];
        }
      }
    }
    sdk.updateSetting('enforcedOrgs', enforcedOrgs);
    const oldKey = sdk.getSetting('apiKey');
    sdk.updateSetting('apiKey', apiKey);
    sdk.updateSetting('apiBaseUrl', apiBaseUrl);
    sdk.updateSetting('apiProxy', apiProxy);
    spinner.success(`API credentials ${oldKey ? 'updated' : 'set'}`);
  }
};

const description$4 = 'Socket API logout';
const logout = {
  description: description$4,
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} logout`;
    const cli = meow(`
      Usage
        $ ${name}

      Logs out of the Socket API and clears all Socket credentials from disk

      Examples
        $ ${name}
    `, {
      argv,
      description: description$4,
      importMeta
    });
    let showHelp = cli.flags['help'];
    if (cli.input.length) {
      showHelp = true;
    }
    if (showHelp) {
      cli.showHelp();
      return;
    }
    sdk.updateSetting('apiKey', null);
    sdk.updateSetting('apiBaseUrl', null);
    sdk.updateSetting('apiProxy', null);
    sdk.updateSetting('enforcedOrgs', null);
    yoctoSpinner().success('Successfully logged out');
  }
};

const {
  NPM: NPM$3
} = constants;
const npm = {
  description: `${NPM$3} wrapper functionality`,
  async run(argv) {
    // Lazily access constants.distPath.
    const shadowBin = require(`${constants.distPath}/shadow-bin.js`);
    await shadowBin(NPM$3, argv);
  }
};

const {
  NPX: NPX$1
} = constants;
const npx = {
  description: `${NPX$1} wrapper functionality`,
  async run(argv) {
    // Lazily access constants.distPath.
    const shadowBin = require(`${constants.distPath}/shadow-bin.js`);
    await shadowBin(NPX$1, argv);
  }
};

function existsSync(filepath) {
  try {
    return filepath ? fs.existsSync(filepath) : false;
  } catch {}
  return false;
}
async function findUp(name, {
  cwd = process.cwd()
}) {
  let dir = path.resolve(cwd);
  const {
    root
  } = path.parse(dir);
  const names = [name].flat();
  while (dir && dir !== root) {
    for (const name of names) {
      const filePath = path.join(dir, name);
      try {
        // eslint-disable-next-line no-await-in-loop
        const stats = await fs.promises.stat(filePath);
        if (stats.isFile()) {
          return filePath;
        }
      } catch {}
    }
    dir = path.dirname(dir);
  }
  return undefined;
}
async function readFileBinary(filepath, options) {
  return await fs.promises.readFile(filepath, {
    ...options,
    encoding: 'binary'
  });
}
async function readFileUtf8(filepath, options) {
  return await fs.promises.readFile(filepath, {
    ...options,
    encoding: 'utf8'
  });
}

const {
  BINARY_LOCK_EXT,
  BUN: BUN$1,
  LOCK_EXT: LOCK_EXT$1,
  NPM: NPM$2,
  PNPM: PNPM$1,
  VLT: VLT$1,
  YARN_BERRY: YARN_BERRY$1,
  YARN_CLASSIC: YARN_CLASSIC$1
} = constants;
const AGENTS = [BUN$1, NPM$2, PNPM$1, YARN_BERRY$1, YARN_CLASSIC$1, VLT$1];
const {
  compare: alphanumericComparator
} = new Intl.Collator(undefined, {
  numeric: true,
  sensitivity: 'base'
});
async function getAgentExecPath(agent) {
  return (await which(agent, {
    nothrow: true
  })) ?? agent;
}
async function getAgentVersion(agentExecPath, cwd) {
  let result;
  try {
    result = semver.coerce(
    // All package managers support the "--version" flag.
    (await spawn(agentExecPath, ['--version'], {
      cwd
    })).stdout) ?? undefined;
  } catch {}
  return result;
}

// The order of LOCKS properties IS significant as it affects iteration order.
const LOCKS = {
  [`bun${LOCK_EXT$1}`]: BUN$1,
  [`bun${BINARY_LOCK_EXT}`]: BUN$1,
  // If both package-lock.json and npm-shrinkwrap.json are present in the root
  // of a project, npm-shrinkwrap.json will take precedence and package-lock.json
  // will be ignored.
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson
  'npm-shrinkwrap.json': NPM$2,
  'package-lock.json': NPM$2,
  'pnpm-lock.yaml': PNPM$1,
  'pnpm-lock.yml': PNPM$1,
  [`yarn${LOCK_EXT$1}`]: YARN_CLASSIC$1,
  'vlt-lock.json': VLT$1,
  // Lastly, look for a hidden lock file which is present if .npmrc has package-lock=false:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-lock-json#hidden-lockfiles
  //
  // Unlike the other LOCKS keys this key contains a directory AND filename so
  // it has to be handled differently.
  'node_modules/.package-lock.json': NPM$2
};
const readLockFileByAgent = (() => {
  function wrapReader(reader) {
    return async (...args) => {
      try {
        return await reader(...args);
      } catch {}
      return undefined;
    };
  }
  const binaryReader = wrapReader(readFileBinary);
  const defaultReader = wrapReader(async lockPath => await readFileUtf8(lockPath));
  return {
    [BUN$1]: wrapReader(async (lockPath, agentExecPath) => {
      const ext = path.extname(lockPath);
      if (ext === LOCK_EXT$1) {
        return await defaultReader(lockPath);
      }
      if (ext === BINARY_LOCK_EXT) {
        const lockBuffer = await binaryReader(lockPath);
        if (lockBuffer) {
          try {
            return hyrious__bun_lockb.parse(lockBuffer);
          } catch {}
        }
        // To print a Yarn lockfile to your console without writing it to disk
        // use `bun bun.lockb`.
        // https://bun.sh/guides/install/yarnlock
        return (await spawn(agentExecPath, [lockPath])).stdout.trim();
      }
      return undefined;
    }),
    [NPM$2]: defaultReader,
    [PNPM$1]: defaultReader,
    [VLT$1]: defaultReader,
    [YARN_BERRY$1]: defaultReader,
    [YARN_CLASSIC$1]: defaultReader
  };
})();
async function detect({
  cwd = process.cwd(),
  onUnknown
} = {}) {
  let lockPath = await findUp(Object.keys(LOCKS), {
    cwd
  });
  let lockBasename = lockPath ? path.basename(lockPath) : undefined;
  const isHiddenLockFile = lockBasename === '.package-lock.json';
  const pkgJsonPath = lockPath ? path.resolve(lockPath, `${isHiddenLockFile ? '../' : ''}../package.json`) : await findUp('package.json', {
    cwd
  });
  const pkgPath = existsSync(pkgJsonPath) ? path.dirname(pkgJsonPath) : undefined;
  const editablePkgJson = pkgPath ? await packages.readPackageJson(pkgPath, {
    editable: true
  }) : undefined;
  const pkgJson = editablePkgJson?.content;
  // Read Corepack `packageManager` field in package.json:
  // https://nodejs.org/api/packages.html#packagemanager
  const pkgManager = strings.isNonEmptyString(pkgJson?.packageManager) ? pkgJson.packageManager : undefined;
  let agent;
  let agentVersion;
  if (pkgManager) {
    const atSignIndex = pkgManager.lastIndexOf('@');
    if (atSignIndex !== -1) {
      const name = pkgManager.slice(0, atSignIndex);
      const version = pkgManager.slice(atSignIndex + 1);
      if (version && AGENTS.includes(name)) {
        agent = name;
        agentVersion = semver.coerce(version) ?? undefined;
      }
    }
  }
  if (agent === undefined && !isHiddenLockFile && typeof pkgJsonPath === 'string' && typeof lockBasename === 'string') {
    agent = LOCKS[lockBasename];
  }
  if (agent === undefined) {
    agent = NPM$2;
    onUnknown?.(pkgManager);
  }
  const agentExecPath = await getAgentExecPath(agent);
  const npmExecPath = agent === NPM$2 ? agentExecPath : await getAgentExecPath(NPM$2);
  if (agentVersion === undefined) {
    agentVersion = await getAgentVersion(agentExecPath, cwd);
  }
  if (agent === YARN_CLASSIC$1 && (agentVersion?.major ?? 0) > 1) {
    agent = YARN_BERRY$1;
  }
  const targets = {
    browser: false,
    node: true
  };
  let lockSrc;
  // Lazily access constants.maintainedNodeVersions.
  let minimumNodeVersion = constants.maintainedNodeVersions.previous;
  if (pkgJson) {
    const browserField = pkgJson.browser;
    if (strings.isNonEmptyString(browserField) || objects.isObjectObject(browserField)) {
      targets.browser = true;
    }
    const nodeRange = pkgJson.engines?.['node'];
    if (strings.isNonEmptyString(nodeRange)) {
      const coerced = semver.coerce(nodeRange);
      if (coerced && semver.lt(coerced, minimumNodeVersion)) {
        minimumNodeVersion = coerced.version;
      }
    }
    const browserslistQuery = pkgJson['browserslist'];
    if (Array.isArray(browserslistQuery)) {
      const browserslistTargets = browserslist(browserslistQuery).map(s => s.toLowerCase()).sort(alphanumericComparator);
      const browserslistNodeTargets = browserslistTargets.filter(v => v.startsWith('node ')).map(v => v.slice(5 /*'node '.length*/));
      if (!targets.browser && browserslistTargets.length) {
        targets.browser = browserslistTargets.length !== browserslistNodeTargets.length;
      }
      if (browserslistNodeTargets.length) {
        const coerced = semver.coerce(browserslistNodeTargets[0]);
        if (coerced && semver.lt(coerced, minimumNodeVersion)) {
          minimumNodeVersion = coerced.version;
        }
      }
    }
    // Lazily access constants.maintainedNodeVersions.
    targets.node = constants.maintainedNodeVersions.some(v => semver.satisfies(v, `>=${minimumNodeVersion}`));
    lockSrc = typeof lockPath === 'string' ? await readLockFileByAgent[agent](lockPath, agentExecPath) : undefined;
  } else {
    lockBasename = undefined;
    lockPath = undefined;
  }
  return {
    agent,
    agentExecPath,
    agentVersion,
    lockBasename,
    lockPath,
    lockSrc,
    minimumNodeVersion,
    npmExecPath,
    pkgJson: editablePkgJson,
    pkgPath,
    supported: targets.browser || targets.node,
    targets
  };
}

const {
  BUN,
  LOCK_EXT,
  NPM: NPM$1,
  PNPM,
  UPDATE_SOCKET_OVERRIDES_IN_PACKAGE_LOCK_FILE,
  VLT,
  YARN_BERRY,
  YARN_CLASSIC,
  abortSignal: abortSignal$2,
  execPath,
  rootBinPath
} = constants;
const COMMAND_TITLE = 'Socket Optimize';
const OVERRIDES_FIELD_NAME = 'overrides';
const NPM_OVERRIDE_PR_URL = 'https://github.com/npm/cli/pull/7025';
const PNPM_FIELD_NAME = PNPM;
const PNPM_WORKSPACE = `${PNPM}-workspace`;
const RESOLUTIONS_FIELD_NAME = 'resolutions';
const manifestNpmOverrides = registry.getManifestData(NPM$1);
const getOverridesDataByAgent = {
  [BUN](pkgJson) {
    const overrides = pkgJson?.resolutions ?? {};
    return {
      type: YARN_BERRY,
      overrides
    };
  },
  // npm overrides documentation:
  // https://docs.npmjs.com/cli/v10/configuring-npm/package-json#overrides
  [NPM$1](pkgJson) {
    const overrides = pkgJson?.overrides ?? {};
    return {
      type: NPM$1,
      overrides
    };
  },
  // pnpm overrides documentation:
  // https://pnpm.io/package_json#pnpmoverrides
  [PNPM](pkgJson) {
    const overrides = pkgJson?.pnpm?.overrides ?? {};
    return {
      type: PNPM,
      overrides
    };
  },
  [VLT](pkgJson) {
    const overrides = pkgJson?.overrides ?? {};
    return {
      type: VLT,
      overrides
    };
  },
  // Yarn resolutions documentation:
  // https://yarnpkg.com/configuration/manifest#resolutions
  [YARN_BERRY](pkgJson) {
    const overrides = pkgJson?.resolutions ?? {};
    return {
      type: YARN_BERRY,
      overrides
    };
  },
  // Yarn resolutions documentation:
  // https://classic.yarnpkg.com/en/docs/selective-version-resolutions
  [YARN_CLASSIC](pkgJson) {
    const overrides = pkgJson?.resolutions ?? {};
    return {
      type: YARN_CLASSIC,
      overrides
    };
  }
};
const lockIncludesByAgent = (() => {
  function npmLockIncludes(lockSrc, name) {
    // Detects the package name in the following cases:
    //   "name":
    return lockSrc.includes(`"${name}":`);
  }
  function yarnLockIncludes(lockSrc, name) {
    const escapedName = regexps.escapeRegExp(name);
    return new RegExp(
    // Detects the package name in the following cases:
    //   "name@
    //   , "name@
    //   name@
    //   , name@
    `(?<=(?:^\\s*|,\\s*)"?)${escapedName}(?=@)`, 'm').test(lockSrc);
  }
  return {
    [BUN](lockSrc, name, lockBasename) {
      // This is a bit counterintuitive. When lockBasename ends with a .lockb
      // we treat it as a yarn.lock. When lockBasename ends with a .lock we
      // treat it as a package-lock.json. The bun.lock format is not identical
      // package-lock.json, however it close enough for npmLockIncludes to work.
      const lockScanner = lockBasename?.endsWith(LOCK_EXT) ? npmLockIncludes : yarnLockIncludes;
      return lockScanner(lockSrc, name);
    },
    [NPM$1]: npmLockIncludes,
    [PNPM](lockSrc, name) {
      const escapedName = regexps.escapeRegExp(name);
      return new RegExp(
      // Detects the package name in the following cases:
      //   /name/
      //   'name'
      //   name:
      //   name@
      `(?<=^\\s*)(?:(['/])${escapedName}\\1|${escapedName}(?=[:@]))`, 'm').test(lockSrc);
    },
    [VLT](lockSrc, name) {
      // Detects the package name in the following cases:
      //   "name"
      return lockSrc.includes(`"${name}"`);
    },
    [YARN_BERRY]: yarnLockIncludes,
    [YARN_CLASSIC]: yarnLockIncludes
  };
})();
const updateManifestByAgent = (() => {
  const depFields = ['dependencies', 'devDependencies', 'peerDependencies', 'peerDependenciesMeta', 'optionalDependencies', 'bundleDependencies'];
  function getEntryIndexes(entries, keys) {
    return keys.map(n => entries.findIndex(p => p[0] === n)).filter(n => n !== -1).sort((a, b) => a - b);
  }
  function getLowestEntryIndex(entries, keys) {
    return getEntryIndexes(entries, keys)?.[0] ?? -1;
  }
  function getHighestEntryIndex(entries, keys) {
    return getEntryIndexes(entries, keys).at(-1) ?? -1;
  }
  function updatePkgJson(editablePkgJson, field, value) {
    const pkgJson = editablePkgJson.content;
    const oldValue = pkgJson[field];
    if (oldValue) {
      // The field already exists so we simply update the field value.
      if (field === PNPM_FIELD_NAME) {
        if (objects.hasKeys(value)) {
          editablePkgJson.update({
            [field]: {
              ...(objects.isObject(oldValue) ? oldValue : {}),
              overrides: value
            }
          });
        } else {
          // Properties with undefined values are omitted when saved as JSON.
          editablePkgJson.update(objects.hasKeys(pkgJson[field]) ? {
            [field]: {
              ...(objects.isObject(oldValue) ? oldValue : {}),
              overrides: undefined
            }
          } : {
            [field]: undefined
          });
        }
      } else if (field === OVERRIDES_FIELD_NAME || field === RESOLUTIONS_FIELD_NAME) {
        // Properties with undefined values are omitted when saved as JSON.
        editablePkgJson.update({
          [field]: objects.hasKeys(value) ? value : undefined
        });
      } else {
        editablePkgJson.update({
          [field]: value
        });
      }
      return;
    }
    if ((field === OVERRIDES_FIELD_NAME || field === PNPM_FIELD_NAME || field === RESOLUTIONS_FIELD_NAME) && !objects.hasKeys(value)) {
      return;
    }
    // Since the field doesn't exist we want to insert it into the package.json
    // in a place that makes sense, e.g. close to the "dependencies" field. If
    // we can't find a place to insert the field we'll add it to the bottom.
    const entries = Object.entries(pkgJson);
    let insertIndex = -1;
    let isPlacingHigher = false;
    if (field === OVERRIDES_FIELD_NAME) {
      insertIndex = getLowestEntryIndex(entries, [RESOLUTIONS_FIELD_NAME]);
      if (insertIndex === -1) {
        isPlacingHigher = true;
        insertIndex = getHighestEntryIndex(entries, [...depFields, PNPM]);
      }
    } else if (field === RESOLUTIONS_FIELD_NAME) {
      isPlacingHigher = true;
      insertIndex = getHighestEntryIndex(entries, [...depFields, OVERRIDES_FIELD_NAME, PNPM]);
    } else if (field === PNPM_FIELD_NAME) {
      insertIndex = getLowestEntryIndex(entries, [OVERRIDES_FIELD_NAME, RESOLUTIONS_FIELD_NAME]);
      if (insertIndex === -1) {
        isPlacingHigher = true;
        insertIndex = getHighestEntryIndex(entries, depFields);
      }
    }
    if (insertIndex === -1) {
      insertIndex = getLowestEntryIndex(entries, ['engines', 'files']);
    }
    if (insertIndex === -1) {
      isPlacingHigher = true;
      insertIndex = getHighestEntryIndex(entries, ['exports', 'imports', 'main']);
    }
    if (insertIndex === -1) {
      insertIndex = entries.length;
    } else if (isPlacingHigher) {
      insertIndex += 1;
    }
    entries.splice(insertIndex, 0, [field, value]);
    editablePkgJson.fromJSON(`${JSON.stringify(Object.fromEntries(entries), null, 2)}\n`);
  }
  function updateOverrides(editablePkgJson, overrides) {
    updatePkgJson(editablePkgJson, OVERRIDES_FIELD_NAME, overrides);
  }
  function updateResolutions(editablePkgJson, overrides) {
    updatePkgJson(editablePkgJson, RESOLUTIONS_FIELD_NAME, overrides);
  }
  return {
    [BUN]: updateResolutions,
    [NPM$1]: updateOverrides,
    [PNPM](editablePkgJson, overrides) {
      updatePkgJson(editablePkgJson, PNPM_FIELD_NAME, overrides);
    },
    [VLT]: updateOverrides,
    [YARN_BERRY]: updateResolutions,
    [YARN_CLASSIC]: updateResolutions
  };
})();
const lsByAgent = (() => {
  function cleanupQueryStdout(stdout) {
    if (stdout === '') {
      return '';
    }
    let pkgs;
    try {
      pkgs = JSON.parse(stdout);
    } catch {}
    if (!Array.isArray(pkgs)) {
      return '';
    }
    const names = new Set();
    for (const {
      _id,
      name,
      pkgid
    } of pkgs) {
      // `npm query` results may not have a "name" property, in which case we
      // fallback to "_id" and then "pkgid".
      // `vlt ls --view json` results always have a "name" property.
      const fallback = _id ?? pkgid ?? '';
      const resolvedName = name ?? fallback.slice(0, fallback.indexOf('@', 1));
      // Add package names, except for those under the `@types` scope as those
      // are known to only be dev dependencies.
      if (resolvedName && !resolvedName.startsWith('@types/')) {
        names.add(resolvedName);
      }
    }
    return JSON.stringify([...names], null, 2);
  }
  function parseableToQueryStdout(stdout) {
    if (stdout === '') {
      return '';
    }
    // Convert the parseable stdout into a json array of unique names.
    // The matchAll regexp looks for a forward (posix) or backward (win32) slash
    // and matches one or more non-slashes until the newline.
    const names = new Set(stdout.matchAll(/(?<=[/\\])[^/\\]+(?=\n)/g));
    return JSON.stringify([...names], null, 2);
  }
  async function npmQuery(npmExecPath, cwd) {
    let stdout = '';
    try {
      stdout = (await spawn(npmExecPath, ['query', ':not(.dev)'], {
        cwd
      })).stdout;
    } catch {}
    return cleanupQueryStdout(stdout);
  }
  return {
    async [BUN](agentExecPath, cwd) {
      try {
        // Bun does not support filtering by production packages yet.
        // https://github.com/oven-sh/bun/issues/8283
        return (await spawn(agentExecPath, ['pm', 'ls', '--all'], {
          cwd
        })).stdout;
      } catch {}
      return '';
    },
    async [NPM$1](agentExecPath, cwd) {
      return await npmQuery(agentExecPath, cwd);
    },
    async [PNPM](agentExecPath, cwd, options) {
      const {
        npmExecPath
      } = {
        __proto__: null,
        ...options
      };
      if (npmExecPath && npmExecPath !== NPM$1) {
        const result = await npmQuery(npmExecPath, cwd);
        if (result) {
          return result;
        }
      }
      let stdout = '';
      try {
        stdout = (await spawn(agentExecPath, ['ls', '--parseable', '--prod', '--depth', 'Infinity'], {
          cwd
        })).stdout;
      } catch {}
      return parseableToQueryStdout(stdout);
    },
    async [VLT](agentExecPath, cwd) {
      let stdout = '';
      try {
        stdout = (await spawn(agentExecPath, ['ls', '--view', 'human', ':not(.dev)'], {
          cwd
        })).stdout;
      } catch {}
      return cleanupQueryStdout(stdout);
    },
    async [YARN_BERRY](agentExecPath, cwd) {
      try {
        return (
          // Yarn Berry does not support filtering by production packages yet.
          // https://github.com/yarnpkg/berry/issues/5117
          (await spawn(agentExecPath, ['info', '--recursive', '--name-only'], {
            cwd
          })).stdout.trim()
        );
      } catch {}
      return '';
    },
    async [YARN_CLASSIC](agentExecPath, cwd) {
      try {
        // However, Yarn Classic does support it.
        // https://github.com/yarnpkg/yarn/releases/tag/v1.0.0
        // > Fix: Excludes dev dependencies from the yarn list output when the
        //   environment is production
        return (await spawn(agentExecPath, ['list', '--prod'], {
          cwd
        })).stdout.trim();
      } catch {}
      return '';
    }
  };
})();
const depsIncludesByAgent = (() => {
  function matchHumanStdout(stdout, name) {
    return stdout.includes(` ${name}@`);
  }
  function matchQueryStdout(stdout, name) {
    return stdout.includes(`"${name}"`);
  }
  return {
    [BUN]: matchHumanStdout,
    [NPM$1]: matchQueryStdout,
    [PNPM]: matchQueryStdout,
    [VLT]: matchQueryStdout,
    [YARN_BERRY]: matchHumanStdout,
    [YARN_CLASSIC]: matchHumanStdout
  };
})();
function createActionMessage(verb, overrideCount, workspaceCount) {
  return `${verb} ${overrideCount} Socket.dev optimized overrides${workspaceCount ? ` in ${workspaceCount} ${words.pluralize('workspace', workspaceCount)}` : ''}`;
}
function getDependencyEntries(pkgJson) {
  const {
    dependencies,
    devDependencies,
    optionalDependencies,
    peerDependencies
  } = pkgJson;
  return [['dependencies', dependencies ? {
    __proto__: null,
    ...dependencies
  } : undefined], ['devDependencies', devDependencies ? {
    __proto__: null,
    ...devDependencies
  } : undefined], ['peerDependencies', peerDependencies ? {
    __proto__: null,
    ...peerDependencies
  } : undefined], ['optionalDependencies', optionalDependencies ? {
    __proto__: null,
    ...optionalDependencies
  } : undefined]].filter(({
    1: o
  }) => o);
}
async function getWorkspaceGlobs(agent, pkgPath, pkgJson) {
  let workspacePatterns;
  if (agent === PNPM) {
    for (const workspacePath of [path.join(pkgPath, `${PNPM_WORKSPACE}.yaml`), path.join(pkgPath, `${PNPM_WORKSPACE}.yml`)]) {
      if (existsSync(workspacePath)) {
        try {
          workspacePatterns = yaml.parse(
          // eslint-disable-next-line no-await-in-loop
          await fs$1.readFile(workspacePath, 'utf8'))?.packages;
        } catch {}
        if (workspacePatterns) {
          break;
        }
      }
    }
  } else {
    workspacePatterns = pkgJson['workspaces'];
  }
  return Array.isArray(workspacePatterns) ? workspacePatterns.filter(strings.isNonEmptyString).map(workspacePatternToGlobPattern) : undefined;
}
function workspacePatternToGlobPattern(workspace) {
  const {
    length
  } = workspace;
  if (!length) {
    return '';
  }
  // If the workspace ends with "/"
  if (workspace.charCodeAt(length - 1) === 47 /*'/'*/) {
    return `${workspace}/*/package.json`;
  }
  // If the workspace ends with "/**"
  if (workspace.charCodeAt(length - 1) === 42 /*'*'*/ && workspace.charCodeAt(length - 2) === 42 /*'*'*/ && workspace.charCodeAt(length - 3) === 47 /*'/'*/) {
    return `${workspace}/*/**/package.json`;
  }
  // Things like "packages/a" or "packages/*"
  return `${workspace}/package.json`;
}
function createAddOverridesState(initials) {
  return {
    added: new Set(),
    addedInWorkspaces: new Set(),
    spinner: undefined,
    updated: new Set(),
    updatedInWorkspaces: new Set(),
    warnedPnpmWorkspaceRequiresNpm: false,
    ...initials
  };
}
async function addOverrides({
  agent,
  agentExecPath,
  lockBasename,
  lockSrc,
  manifestEntries,
  npmExecPath,
  pin,
  pkgJson: editablePkgJson,
  pkgPath,
  prod,
  rootPath
}, state = createAddOverridesState()) {
  if (editablePkgJson === undefined) {
    editablePkgJson = await packages.readPackageJson(pkgPath, {
      editable: true
    });
  }
  const {
    spinner
  } = state;
  const {
    content: pkgJson
  } = editablePkgJson;
  const isRoot = pkgPath === rootPath;
  const isLockScanned = isRoot && !prod;
  const workspaceName = path.relative(rootPath, pkgPath);
  const workspaceGlobs = await getWorkspaceGlobs(agent, pkgPath, pkgJson);
  const isWorkspace = !!workspaceGlobs;
  if (isWorkspace && agent === PNPM && npmExecPath === NPM$1 && !state.warnedPnpmWorkspaceRequiresNpm) {
    state.warnedPnpmWorkspaceRequiresNpm = true;
    console.warn(`⚠️ ${COMMAND_TITLE}: pnpm workspace support requires \`npm ls\`, falling back to \`pnpm list\``);
  }
  const thingToScan = isLockScanned ? lockSrc : await lsByAgent[agent](agentExecPath, pkgPath, {
    npmExecPath
  });
  // The AgentDepsIncludesFn and AgentLockIncludesFn types overlap in their
  // first two parameters. AgentLockIncludesFn accepts an optional third
  // parameter which AgentDepsIncludesFn will ignore so we cast thingScanner
  // as an AgentLockIncludesFn type.
  const thingScanner = isLockScanned ? lockIncludesByAgent[agent] : depsIncludesByAgent[agent];
  const depEntries = getDependencyEntries(pkgJson);
  const overridesDataObjects = [];
  if (pkgJson['private'] || isWorkspace) {
    overridesDataObjects.push(getOverridesDataByAgent[agent](pkgJson));
  } else {
    overridesDataObjects.push(getOverridesDataByAgent[NPM$1](pkgJson), getOverridesDataByAgent[YARN_CLASSIC](pkgJson));
  }
  if (spinner) {
    spinner.text = `Adding overrides${workspaceName ? ` to ${workspaceName}` : ''}...`;
  }
  const depAliasMap = new Map();
  // Chunk package names to process them in parallel 3 at a time.
  await promises.pEach(manifestEntries, 3, async ({
    1: data
  }) => {
    const {
      name: regPkgName,
      package: origPkgName,
      version
    } = data;
    const major = semver.major(version);
    for (const {
      1: depObj
    } of depEntries) {
      let pkgSpec = depObj[origPkgName];
      if (pkgSpec) {
        let thisVersion = version;
        // Add package aliases for direct dependencies to avoid npm EOVERRIDE errors.
        // https://docs.npmjs.com/cli/v8/using-npm/package-spec#aliases
        const regSpecStartsLike = `npm:${regPkgName}@`;
        const existingVersion = pkgSpec.startsWith(regSpecStartsLike) ? semver.coerce(npa(pkgSpec).rawSpec)?.version ?? '' : '';
        if (existingVersion) {
          thisVersion = existingVersion;
        } else {
          pkgSpec = `${regSpecStartsLike}^${version}`;
          depObj[origPkgName] = pkgSpec;
          state.added.add(regPkgName);
          if (workspaceName) {
            state.addedInWorkspaces.add(workspaceName);
          }
        }
        depAliasMap.set(origPkgName, {
          id: pkgSpec,
          version: thisVersion
        });
      }
    }
    if (isRoot) {
      // Chunk package names to process them in parallel 3 at a time.
      await promises.pEach(overridesDataObjects, 3, async ({
        overrides,
        type
      }) => {
        const overrideExists = objects.hasOwn(overrides, origPkgName);
        if (overrideExists || thingScanner(thingToScan, origPkgName, lockBasename)) {
          const oldSpec = overrideExists ? overrides[origPkgName] : undefined;
          const depAlias = depAliasMap.get(origPkgName);
          const regSpecStartsLike = `${NPM$1}:${regPkgName}@`;
          let newSpec = `${regSpecStartsLike}^${pin ? version : major}`;
          let thisVersion = version;
          if (depAlias && type === NPM$1) {
            // With npm one may not set an override for a package that one directly
            // depends on unless both the dependency and the override itself share
            // the exact same spec. To make this limitation easier to deal with,
            // overrides may also be defined as a reference to a spec for a direct
            // dependency by prefixing the name of the package to match the version
            // of with a $.
            // https://docs.npmjs.com/cli/v8/configuring-npm/package-json#overrides
            newSpec = `$${origPkgName}`;
          } else if (overrideExists) {
            const thisSpec = oldSpec.startsWith('$') ? depAlias?.id ?? newSpec : oldSpec ?? newSpec;
            if (thisSpec.startsWith(regSpecStartsLike)) {
              if (pin) {
                thisVersion = semver.major(semver.coerce(npa(thisSpec).rawSpec)?.version ?? version) === major ? version : (await packages.fetchPackageManifest(thisSpec))?.version ?? version;
              }
              newSpec = `${regSpecStartsLike}^${pin ? thisVersion : semver.major(thisVersion)}`;
            } else {
              newSpec = oldSpec;
            }
          }
          if (newSpec !== oldSpec) {
            overrides[origPkgName] = newSpec;
            const addedOrUpdated = overrideExists ? 'updated' : 'added';
            state[addedOrUpdated].add(regPkgName);
          }
        }
      });
    }
  });
  if (workspaceGlobs) {
    const workspacePkgJsonPaths = await tinyglobby.glob(workspaceGlobs, {
      absolute: true,
      cwd: pkgPath,
      ignore: ['**/node_modules/**', '**/bower_components/**']
    });
    // Chunk package names to process them in parallel 3 at a time.
    await promises.pEach(workspacePkgJsonPaths, 3, async workspacePkgJsonPath => {
      const otherState = await addOverrides({
        agent,
        agentExecPath,
        lockBasename,
        lockSrc,
        manifestEntries,
        npmExecPath,
        pin,
        pkgPath: path.dirname(workspacePkgJsonPath),
        prod,
        rootPath
      }, createAddOverridesState({
        spinner
      }));
      for (const key of ['added', 'addedInWorkspaces', 'updated', 'updatedInWorkspaces']) {
        for (const value of otherState[key]) {
          state[key].add(value);
        }
      }
    });
  }
  if (state.added.size > 0 || state.updated.size > 0) {
    editablePkgJson.update(Object.fromEntries(depEntries));
    for (const {
      overrides,
      type
    } of overridesDataObjects) {
      updateManifestByAgent[type](editablePkgJson, objects.toSortedObject(overrides));
    }
    await editablePkgJson.save();
  }
  return state;
}
const optimize = {
  description: 'Optimize dependencies with @socketregistry overrides',
  async run(argv, importMeta, {
    parentName
  }) {
    const commandContext = setupCommand$l(`${parentName} optimize`, optimize.description, argv, importMeta);
    if (!commandContext) {
      return;
    }
    const {
      pin,
      prod
    } = commandContext;
    const cwd = process.cwd();
    const {
      agent,
      agentExecPath,
      agentVersion,
      lockBasename,
      lockPath,
      lockSrc,
      minimumNodeVersion,
      npmExecPath,
      pkgJson,
      pkgPath,
      supported
    } = await detect({
      cwd,
      onUnknown(pkgManager) {
        console.warn(`⚠️ ${COMMAND_TITLE}: Unknown package manager${pkgManager ? ` ${pkgManager}` : ''}, defaulting to npm`);
      }
    });
    if (!supported) {
      console.error(`✖️ ${COMMAND_TITLE}: No supported Node or browser range detected`);
      return;
    }
    if (agent === VLT) {
      console.error(`✖️ ${COMMAND_TITLE}: ${agent} does not support overrides. Soon, though ⚡`);
      return;
    }
    const lockName = lockPath ? lockBasename : 'lock file';
    if (lockBasename === undefined || lockSrc === undefined) {
      console.error(`✖️ ${COMMAND_TITLE}: No ${lockName} found`);
      return;
    }
    if (lockSrc.trim() === '') {
      console.error(`✖️ ${COMMAND_TITLE}: ${lockName} is empty`);
      return;
    }
    if (pkgPath === undefined) {
      console.error(`✖️ ${COMMAND_TITLE}: No package.json found`);
      return;
    }
    if (prod && (agent === BUN || agent === YARN_BERRY)) {
      console.error(`✖️ ${COMMAND_TITLE}: --prod not supported for ${agent}${agentVersion ? `@${agentVersion.toString()}` : ''}`);
      return;
    }
    if (lockPath && path.relative(cwd, lockPath).startsWith('.')) {
      console.warn(`⚠️ ${COMMAND_TITLE}: Package ${lockName} found at ${lockPath}`);
    }
    const spinner = yoctoSpinner({
      text: 'Socket optimizing...'
    });
    const state = createAddOverridesState({
      spinner
    });
    spinner.start();
    const nodeRange = `>=${minimumNodeVersion}`;
    const manifestEntries = manifestNpmOverrides.filter(({
      1: data
    }) => semver.satisfies(semver.coerce(data.engines.node), nodeRange));
    await addOverrides({
      agent,
      agentExecPath,
      lockBasename,
      lockSrc,
      manifestEntries,
      npmExecPath,
      pin,
      pkgJson,
      pkgPath,
      prod,
      rootPath: pkgPath
    }, state);
    spinner.stop();
    const addedCount = state.added.size;
    const updatedCount = state.updated.size;
    const pkgJsonChanged = addedCount > 0 || updatedCount > 0;
    if (pkgJsonChanged) {
      if (updatedCount > 0) {
        console.log(`${createActionMessage('Updated', updatedCount, state.updatedInWorkspaces.size)}${addedCount ? '.' : '🚀'}`);
      }
      if (addedCount > 0) {
        console.log(`${createActionMessage('Added', addedCount, state.addedInWorkspaces.size)} 🚀`);
      }
    } else {
      console.log('Congratulations! Already Socket.dev optimized 🎉');
    }
    const isNpm = agent === NPM$1;
    if (isNpm || pkgJsonChanged) {
      // Always update package-lock.json until the npm overrides PR lands:
      // https://github.com/npm/cli/pull/7025
      spinner.start(`Updating ${lockName}...`);
      try {
        if (isNpm) {
          const wrapperPath = path.join(rootBinPath, 'npm-cli.js');
          const npmSpawnOptions = {
            signal: abortSignal$2,
            stdio: 'ignore',
            env: {
              ...process.env,
              [UPDATE_SOCKET_OVERRIDES_IN_PACKAGE_LOCK_FILE]: '1'
            }
          };
          await spawn(execPath, [wrapperPath, 'install', '--silent'], npmSpawnOptions);
          // TODO: This is a temporary workaround for a `npm ci` bug where it
          // will error out after Socket Optimize generates a lock file. More
          // investigation is needed.
          await spawn(execPath, [wrapperPath, 'install', '--silent', '--ignore-scripts', '--package-lock-only'], npmSpawnOptions);
        } else {
          // All package managers support the "install" command.
          await spawn(agentExecPath, ['install'], {
            signal: abortSignal$2,
            stdio: 'ignore'
          });
        }
        spinner.stop();
        if (isNpm) {
          console.log(`💡 Re-run ${COMMAND_TITLE} whenever ${lockName} changes.\n   This can be skipped once npm ships ${NPM_OVERRIDE_PR_URL}.`);
        }
      } catch {
        spinner.error(`${COMMAND_TITLE}: ${agent} install failed to update ${lockName}`);
      }
    }
  }
};

// Internal functions

function setupCommand$l(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    pin: {
      type: 'boolean',
      default: false,
      description: 'Pin overrides to their latest version'
    },
    prod: {
      type: 'boolean',
      default: false,
      description: 'Only add overrides for production dependencies'
    }
  };
  const cli = meow(`
    Usage
      $ ${name}

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name}
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    help,
    pin,
    prod
  } = cli.flags;
  if (help) {
    cli.showHelp();
    return;
  }
  return {
    pin,
    prod
  };
}

const organizations = {
  description: 'List organizations associated with the API key used',
  async run(argv, importMeta, {
    parentName
  }) {
    setupCommand$k(`${parentName} organizations`, organizations.description, argv, importMeta);
    await fetchOrganizations();
  }
};

// Internal functions

function setupCommand$k(name, description, argv, importMeta) {
  meow(`
    Usage
      $ ${name}
  `, {
    argv,
    description,
    importMeta
  });
}
async function fetchOrganizations() {
  const apiKey = sdk.getDefaultKey();
  if (!apiKey) {
    throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  const spinner = yoctoSpinner({
    text: 'Fetching organizations...'
  }).start();
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getOrganizations(), 'looking up organizations');
  if (result.success === false) {
    handleUnsuccessfulApiResponse('getOrganizations', result, spinner);
    return;
  }
  spinner.stop(`List of organizations associated with your API key: ${colors.italic(apiKey)}`);
  const organizations = Object.values(result.data.organizations);
  for (const o of organizations) {
    console.log(`
Name: ${o?.name}
ID: ${o?.id}
Plan: ${o?.plan}
    `);
  }
}

const {
  NPM,
  abortSignal: abortSignal$1
} = constants;
const binName$1 = NPM;
const rawNpm = {
  description: `Temporarily disable the Socket ${binName$1} wrapper`,
  async run(argv, importMeta, {
    parentName
  }) {
    await setupCommand$j(`${parentName} raw-${binName$1}`, rawNpm.description, argv, importMeta);
  }
};
async function setupCommand$j(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...validationFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <${binName$1} command>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} install
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!argv[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    path: binPath
  } = await pathResolve.findBinPathDetails(binName$1);
  if (!binPath) {
    // The exit code 127 indicates that the command or binary being executed
    // could not be found.
    console.error(`Socket unable to locate ${binName$1}; ensure it is available in the PATH environment variable.`);
    process.exit(127);
  }
  const spawnPromise = spawn(binPath, argv, {
    signal: abortSignal$1,
    stdio: 'inherit'
  });
  // See https://nodejs.org/api/all.html#all_child_process_event-exit.
  spawnPromise.process.on('exit', (code, signalName) => {
    if (abortSignal$1.aborted) {
      return;
    }
    if (signalName) {
      process.kill(process.pid, signalName);
    } else if (code !== null) {
      process.exit(code);
    }
  });
  await spawnPromise;
}

const {
  NPX,
  abortSignal
} = constants;
const binName = NPX;
const rawNpx = {
  description: `Temporarily disable the Socket ${binName} wrapper`,
  async run(argv, importMeta, {
    parentName
  }) {
    await setupCommand$i(`${parentName} raw-${binName}`, rawNpx.description, argv, importMeta);
  }
};
async function setupCommand$i(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...validationFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <${binName} command>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} install
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!argv[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    path: binPath
  } = await pathResolve.findBinPathDetails(binName);
  if (!binPath) {
    // The exit code 127 indicates that the command or binary being executed
    // could not be found.
    console.error(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable.`);
    process.exit(127);
  }
  const spawnPromise = spawn(binPath, argv, {
    signal: abortSignal,
    stdio: 'inherit'
  });
  // See https://nodejs.org/api/all.html#all_child_process_event-exit.
  spawnPromise.process.on('exit', (code, signalName) => {
    if (abortSignal.aborted) {
      return;
    }
    if (signalName) {
      process.kill(process.pid, signalName);
    } else if (code !== null) {
      process.exit(code);
    }
  });
  await spawnPromise;
}

const view$1 = {
  description: 'View a project report',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} view`;
    const commandContext = setupCommand$h(name, view$1.description, argv, importMeta);
    const result = commandContext ? await fetchReportData(commandContext.reportId, commandContext) : undefined;
    if (result) {
      formatReportDataOutput(result, {
        name,
        ...(commandContext ?? {})
      });
    }
  }
};

// Internal functions

function setupCommand$h(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <report-identifier>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} QXU8PmK7LfH608RAwfIKdbcHgwEd_ZeWJ9QEGv05FJUQ
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  // Extract the input.
  const [reportId, ...extraInput] = cli.input;
  let showHelp = cli.flags['help'];
  if (reportId) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  // Validate the input.
  if (extraInput.length) {
    throw new sdk.InputError(`Can only handle a single report ID at a time, but got ${cli.input.length} report ID:s: ${cli.input.join(', ')}`);
  }
  return {
    includeAllIssues: cli.flags['all'],
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    reportId,
    strict: cli.flags['strict']
  };
}
const MAX_TIMEOUT_RETRY = 5;
async function fetchReportData(reportId, {
  includeAllIssues,
  strict
}) {
  // Do the API call
  const socketSdk = await sdk.setupSdk();
  const spinner = yoctoSpinner({
    text: `Fetching report with ID ${reportId} (this could take a while)`
  }).start();
  let result;
  for (let retry = 1; !result; ++retry) {
    try {
      // eslint-disable-next-line no-await-in-loop
      result = await handleApiCall(socketSdk.getReport(reportId), 'fetching report');
    } catch (err) {
      if (retry >= MAX_TIMEOUT_RETRY || !(err instanceof ponyCause.ErrorWithCause) || err.cause?.cause?.response?.statusCode !== 524) {
        throw err;
      }
    }
  }
  if (result.success === false) {
    return handleUnsuccessfulApiResponse('getReport', result, spinner);
  }

  // Conclude the status of the API call

  if (strict) {
    if (result.data.healthy) {
      spinner.success('Report result is healthy and great!');
    } else {
      spinner.error('Report result deemed unhealthy for project');
    }
  } else if (result.data.healthy === false) {
    const severityCount = getSeverityCount(result.data.issues, includeAllIssues ? undefined : 'high');
    const issueSummary = formatSeverityCount(severityCount);
    spinner.success(`Report has these issues: ${issueSummary}`);
  } else {
    spinner.success('Report has no issues');
  }
  return result.data;
}
function formatReportDataOutput(data, {
  name,
  outputJson,
  outputMarkdown,
  reportId,
  strict
}) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
  } else {
    const format = new sdk.ColorOrMarkdown(!!outputMarkdown);
    console.log('\nDetailed info on socket.dev: ' + format.hyperlink(reportId, data.url, {
      fallbackToUrl: true
    }));
    if (!outputMarkdown) {
      console.log(colors.dim(`\nOr rerun ${colors.italic(name)} using the ${colors.italic('--json')} flag to get full JSON output`));
    }
  }
  if (strict && data.healthy === false) {
    process.exit(1);
  }
}

const create$2 = {
  description: 'Create a project report',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} create`;
    const input = await setupCommand$g(name, create$2.description, argv, importMeta);
    if (input) {
      const {
        config,
        cwd,
        debugLog,
        dryRun,
        includeAllIssues,
        outputJson,
        outputMarkdown,
        packagePaths,
        strict,
        view
      } = input;
      const result = input && (await createReport(packagePaths, {
        config,
        cwd,
        debugLog,
        dryRun
      }));
      if (result && view) {
        const reportId = result.data.id;
        const reportData = input && (await fetchReportData(reportId, {
          includeAllIssues,
          strict
        }));
        if (reportData) {
          formatReportDataOutput(reportData, {
            includeAllIssues,
            name,
            outputJson,
            outputMarkdown,
            reportId,
            strict
          });
        }
      } else if (result) {
        formatReportCreationOutput(result.data, {
          outputJson,
          outputMarkdown
        });
      }
    }
  }
};

// Internal functions

async function setupCommand$g(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...validationFlags,
    debug: {
      type: 'boolean',
      shortFlag: 'd',
      default: false,
      description: 'Output debug information'
    },
    dryRun: {
      type: 'boolean',
      default: false,
      description: 'Only output what will be done without actually doing it'
    },
    view: {
      type: 'boolean',
      shortFlag: 'v',
      default: false,
      description: 'Will wait for and return the created report'
    }
  };
  const cli = meow(`
    Usage
      $ ${name} <paths-to-package-folders-and-files>

    Uploads the specified "package.json" and lock files for JavaScript, Python, and Go dependency manifests.
    If any folder is specified, the ones found in there recursively are uploaded.

    Supports globbing such as "**/package.json", "**/requirements.txt", "**/pyproject.toml", and "**/go.mod".

    Ignores any file specified in your project's ".gitignore", your project's
    "socket.yml" file's "projectIgnorePaths" and also has a sensible set of
    default ignores from the "ignore-by-default" module.

    Options
      ${printFlagList({
    all: 'Include all issues',
    debug: 'Output debug information',
    'dry-run': 'Only output what will be done without actually doing it',
    json: 'Output result as json',
    markdown: 'Output result as markdown',
    strict: 'Exits with an error code if any matching issues are found',
    view: 'Will wait for and return the created report'
  }, 6)}

    Examples
      $ ${name} .
      $ ${name} '**/package.json'
      $ ${name} /path/to/a/package.json /path/to/another/package.json
      $ ${name} . --view --json
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    dryRun
  } = cli.flags;
  const debugLog = sdk.createDebugLogger(!dryRun || cli.flags['debug']);

  // TODO: Allow setting a custom cwd and/or configFile path?
  const cwd = process.cwd();
  const absoluteConfigPath = path.join(cwd, 'socket.yml');
  const config$1 = await config.readSocketConfig(absoluteConfigPath).catch(cause => {
    if (cause && typeof cause === 'object' && cause instanceof config.SocketValidationError) {
      // Inspired by workbox-build:
      // https://github.com/GoogleChrome/workbox/blob/95f97a207fd51efb3f8a653f6e3e58224183a778/packages/workbox-build/src/lib/validate-options.ts#L68-L71
      const betterErrors = betterAjvErrors.betterAjvErrors({
        basePath: 'config',
        data: cause.data,
        errors: cause.validationErrors,
        schema: cause.schema
      });
      throw new sdk.InputError('The socket.yml config is not valid', betterErrors.map(err => `[${err.path}] ${err.message}.${err.suggestion ? err.suggestion : ''}`).join('\n'));
    } else {
      throw new ponyCause.ErrorWithCause('Failed to read socket.yml config', {
        cause
      });
    }
  });
  const socketSdk = await sdk.setupSdk();
  const supportedFiles = await socketSdk.getReportSupportedFiles().then(res => {
    if (!res.success) handleUnsuccessfulApiResponse('getReportSupportedFiles', res, yoctoSpinner());
    return res.data;
  }).catch(cause => {
    throw new ponyCause.ErrorWithCause('Failed getting supported files for report', {
      cause
    });
  });
  const packagePaths = await pathResolve.getPackageFiles(cwd, cli.input, config$1, supportedFiles, debugLog);
  return {
    config: config$1,
    cwd,
    debugLog,
    dryRun,
    includeAllIssues: cli.flags['all'],
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    packagePaths,
    strict: cli.flags['strict'],
    view: cli.flags['view']
  };
}
async function createReport(packagePaths, {
  config,
  cwd,
  debugLog,
  dryRun
}) {
  debugLog('Uploading:', packagePaths.join(`\n${sdk.logSymbols.info} Uploading: `));
  if (dryRun) {
    return;
  }
  const socketSdk = await sdk.setupSdk();
  const spinner = yoctoSpinner({
    text: `Creating report with ${packagePaths.length} package files`
  }).start();
  const apiCall = socketSdk.createReportFromFilePaths(packagePaths, cwd, config?.issueRules);
  const result = await handleApiCall(apiCall, 'creating report');
  if (result.success) {
    spinner.success();
    return result;
  }
  handleUnsuccessfulApiResponse('createReport', result, spinner);
  return undefined;
}
function formatReportCreationOutput(data, {
  outputJson,
  outputMarkdown
}) {
  if (outputJson) {
    console.log(JSON.stringify(data, undefined, 2));
    return;
  }
  const format = new sdk.ColorOrMarkdown(!!outputMarkdown);
  console.log(`New report: ${format.hyperlink(data.id, data.url, {
    fallbackToUrl: true
  })}`);
}

async function meowWithSubcommands(subcommands, options) {
  const {
    aliases = {},
    argv,
    importMeta,
    name,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const [commandOrAliasName, ...rawCommandArgv] = argv;
  // If we got at least some args, then lets find out if we can find a command
  if (commandOrAliasName) {
    const alias = aliases[commandOrAliasName];
    // First: Resolve argv data from alias if its an alias that's been given
    const [commandName, ...commandArgv] = alias ? [...alias.argv, ...rawCommandArgv] : [commandOrAliasName, ...rawCommandArgv];
    // Second: Find a command definition using that data
    const commandDefinition = commandName ? subcommands[commandName] : undefined;
    // Third: If a valid command has been found, then we run it...
    if (commandDefinition) {
      return await commandDefinition.run(commandArgv, importMeta, {
        parentName: name
      });
    }
  }
  const flags = {
    ...commonFlags,
    ...additionalOptions.flags
  };
  // ...else we provide basic instructions and help
  const cli = meow(`
    Usage
      $ ${name} <command>

    Commands
      ${printHelpList({
    ...objects.toSortedObject(subcommands),
    ...objects.toSortedObject(aliases)
  }, 6)}

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} --help
  `, {
    argv,
    importMeta,
    ...additionalOptions,
    flags
  });
  cli.showHelp();
}

const description$3 = '[Deprecated] Project report related commands';
const report = {
  description: description$3,
  async run(argv, importMeta, {
    parentName
  }) {
    await meowWithSubcommands({
      create: create$2,
      view: view$1
    }, {
      argv,
      description: description$3,
      importMeta,
      name: parentName + ' report'
    });
  }
};

const BASH_FILE = `${homedir.homedir()}/.bashrc`;
const ZSH_BASH_FILE = `${homedir.homedir()}/.zshrc`;
const wrapper = {
  description: 'Enable or disable the Socket npm/npx wrapper',
  async run(argv, importMeta, {
    parentName
  }) {
    setupCommand$f(`${parentName} wrapper`, wrapper.description, argv, importMeta);
  }
};
function setupCommand$f(name, description, argv, importMeta) {
  const flags = commandFlags;
  const cli = meow(`
    Usage
      $ ${name} <flag>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} --enable
      $ ${name} --disable
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  if (argv[0] === '--postinstall') {
    const socketWrapperEnabled = fs.existsSync(BASH_FILE) && checkSocketWrapperAlreadySetup(BASH_FILE) || fs.existsSync(ZSH_BASH_FILE) && checkSocketWrapperAlreadySetup(ZSH_BASH_FILE);
    if (!socketWrapperEnabled) {
      installSafeNpm(`The Socket CLI is now successfully installed! 🎉

      To better protect yourself against supply-chain attacks, our "safe npm" wrapper can warn you about malicious packages whenever you run 'npm install'.

      Do you want to install "safe npm" (this will create an alias to the socket-npm command)? (y/n)`);
    }
    return;
  }
  const {
    disable,
    enable
  } = cli.flags;
  let showHelp = cli.flags['help'];
  if (!enable && !disable) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  if (enable) {
    if (fs.existsSync(BASH_FILE)) {
      const socketWrapperEnabled = checkSocketWrapperAlreadySetup(BASH_FILE);
      !socketWrapperEnabled && addAlias(BASH_FILE);
    }
    if (fs.existsSync(ZSH_BASH_FILE)) {
      const socketWrapperEnabled = checkSocketWrapperAlreadySetup(ZSH_BASH_FILE);
      !socketWrapperEnabled && addAlias(ZSH_BASH_FILE);
    }
  } else if (disable) {
    if (fs.existsSync(BASH_FILE)) {
      removeAlias(BASH_FILE);
    }
    if (fs.existsSync(ZSH_BASH_FILE)) {
      removeAlias(ZSH_BASH_FILE);
    }
  }
  if (!fs.existsSync(BASH_FILE) && !fs.existsSync(ZSH_BASH_FILE)) {
    console.error('There was an issue setting up the alias in your bash profile');
  }
}
const installSafeNpm = query => {
  console.log(`
 _____         _       _
|   __|___ ___| |_ ___| |_
|__   | . |  _| '_| -_|  _|
|_____|___|___|_,_|___|_|

`);
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
  return askQuestion(rl, query);
};
const askQuestion = (rl, query) => {
  rl.question(query, ans => {
    if (ans.toLowerCase() === 'y') {
      try {
        if (fs.existsSync(BASH_FILE)) {
          addAlias(BASH_FILE);
        }
        if (fs.existsSync(ZSH_BASH_FILE)) {
          addAlias(ZSH_BASH_FILE);
        }
      } catch (e) {
        throw new Error(`There was an issue setting up the alias: ${e}`);
      }
      rl.close();
    } else if (ans.toLowerCase() !== 'n') {
      askQuestion(rl, 'Incorrect input: please enter either y (yes) or n (no): ');
    } else {
      rl.close();
    }
  });
};
const addAlias = file => {
  return fs.appendFile(file, 'alias npm="socket npm"\nalias npx="socket npx"\n', err => {
    if (err) {
      return new Error(`There was an error setting up the alias: ${err}`);
    }
    console.log(`
The alias was added to ${file}. Running 'npm install' will now be wrapped in Socket's "safe npm" 🎉
If you want to disable it at any time, run \`socket wrapper --disable\`
`);
  });
};
const removeAlias = file => {
  return fs.readFile(file, 'utf8', function (err, data) {
    if (err) {
      console.error(`There was an error removing the alias: ${err}`);
      return;
    }
    const linesWithoutSocketAlias = data.split('\n').filter(l => l !== 'alias npm="socket npm"' && l !== 'alias npx="socket npx"');
    const updatedFileContent = linesWithoutSocketAlias.join('\n');
    fs.writeFile(file, updatedFileContent, function (err) {
      if (err) {
        console.log(err);
        return;
      } else {
        console.log(`\nThe alias was removed from ${file}. Running 'npm install' will now run the standard npm command.\n`);
      }
    });
  });
};
const checkSocketWrapperAlreadySetup = file => {
  const fileContent = fs.readFileSync(file, 'utf8');
  const linesWithSocketAlias = fileContent.split('\n').filter(l => l === 'alias npm="socket npm"' || l === 'alias npx="socket npx"');
  if (linesWithSocketAlias.length) {
    console.log(`The Socket npm/npx wrapper is set up in your bash profile (${file}).`);
    return true;
  }
  return false;
};

const create$1 = {
  description: 'Create a scan',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} create`;
    const input = await setupCommand$e(name, create$1.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Creating a scan... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await createFullScan(input, spinner, apiKey);
    }
  }
};
const createFullScanFlags = {
  repo: {
    type: 'string',
    shortFlag: 'r',
    default: '',
    description: 'Repository name'
  },
  branch: {
    type: 'string',
    shortFlag: 'b',
    default: '',
    description: 'Branch name'
  },
  commitMessage: {
    type: 'string',
    shortFlag: 'm',
    default: '',
    description: 'Commit message'
  },
  commitHash: {
    type: 'string',
    shortFlag: 'ch',
    default: '',
    description: 'Commit hash'
  },
  pullRequest: {
    type: 'number',
    shortFlag: 'pr',
    description: 'Commit hash'
  },
  committers: {
    type: 'string',
    shortFlag: 'c',
    default: '',
    description: 'Committers'
  },
  defaultBranch: {
    type: 'boolean',
    shortFlag: 'db',
    default: false,
    description: 'Make default branch'
  },
  pendingHead: {
    type: 'boolean',
    shortFlag: 'ph',
    default: false,
    description: 'Set as pending head'
  },
  tmp: {
    type: 'boolean',
    shortFlag: 't',
    default: false,
    description: 'Set the visibility (true/false) of the scan in your dashboard'
  }
};

// Internal functions

async function setupCommand$e(name, description, argv, importMeta) {
  const flags = {
    ...createFullScanFlags
  };
  const cli = meow(`
    Usage
      $ ${name} [...options]

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} --org=FakeOrg --repo=test-repo --branch=main ./package.json
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = ''
  } = cli.input;
  const cwd = process.cwd();
  const socketSdk = await sdk.setupSdk();
  const supportedFiles = await socketSdk.getReportSupportedFiles().then(res => {
    if (!res.success) handleUnsuccessfulApiResponse('getReportSupportedFiles', res, yoctoSpinner());
    return res.data;
  }).catch(/** @type {(cause: Error) => never} */
  cause => {
    throw new ponyCause.ErrorWithCause('Failed getting supported files for report', {
      cause
    });
  });
  const debugLog = sdk.createDebugLogger(false);
  const packagePaths = await pathResolve.getPackageFilesFullScans(cwd, cli.input, supportedFiles, debugLog);
  const {
    branch: branchName,
    repo: repoName
  } = cli.flags;
  if (!repoName || !branchName || !packagePaths.length) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide the required fields:\n
    - Repository name using --repo\n
    - Branch name using --branch\n
    - At least one file path (e.g. ./package.json)`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    orgSlug,
    repoName,
    branchName,
    commitMessage: cli.flags['commitMessage'],
    defaultBranch: cli.flags['defaultBranch'],
    pendingHead: cli.flags['pendingHead'],
    tmp: cli.flags['tmp'],
    packagePaths,
    commitHash: cli.flags['commitHash'],
    committers: cli.flags['committers'],
    pullRequest: cli.flags['pullRequest']
  };
}
async function createFullScan(input, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const {
    branchName,
    commitMessage,
    defaultBranch,
    orgSlug,
    packagePaths,
    pendingHead,
    repoName,
    tmp
  } = input;
  const result = await handleApiCall(socketSdk.createOrgFullScan(orgSlug, {
    repo: repoName,
    branch: branchName,
    commit_message: commitMessage,
    make_default_branch: defaultBranch,
    set_as_pending_head: pendingHead,
    tmp
  }, packagePaths), 'Creating scan');
  if (!result.success) {
    handleUnsuccessfulApiResponse('CreateOrgFullScan', result, spinner);
    return;
  }
  spinner.success('Scan created successfully');
  const link = colors.underline(colors.cyan(`${result.data.html_report_url}`));
  console.log(`Available at: ${link}`);
  const rl = readline$1.createInterface({
    input: node_process.stdin,
    output: node_process.stdout
  });
  const answer = await rl.question('Would you like to open it in your browser? (y/n)');
  if (answer.toLowerCase() === 'y') {
    await open(`${result.data.html_report_url}`);
  }
  rl.close();
}

const del$1 = {
  description: 'Delete a scan',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} del`;
    const input = setupCommand$d(name, del$1.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Deleting scan...';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await deleteOrgFullScan(input.orgSlug, input.fullScanId, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$d(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug> <scan ID>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 2) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please specify an organization slug and a scan ID.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: fullScanId = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    fullScanId
  };
}
async function deleteOrgFullScan(orgSlug, fullScanId, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.deleteOrgFullScan(orgSlug, fullScanId), 'Deleting scan');
  if (result.success) {
    spinner.success('Scan deleted successfully');
  } else {
    handleUnsuccessfulApiResponse('deleteOrgFullScan', result, spinner);
  }
}

const list$1 = {
  description: 'List scans for an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} list`;
    const input = setupCommand$c(name, list$1.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Listing scans... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await listOrgFullScan(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const listFullScanFlags = {
  sort: {
    type: 'string',
    shortFlag: 's',
    default: 'created_at',
    description: 'Sorting option (`name` or `created_at`) - default is `created_at`'
  },
  direction: {
    type: 'string',
    shortFlag: 'd',
    default: 'desc',
    description: 'Direction option (`desc` or `asc`) - Default is `desc`'
  },
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Results per page - Default is 30'
  },
  page: {
    type: 'number',
    shortFlag: 'p',
    default: 1,
    description: 'Page number - Default is 1'
  },
  fromTime: {
    type: 'string',
    shortFlag: 'f',
    default: '',
    description: 'From time - as a unix timestamp'
  },
  untilTime: {
    type: 'string',
    shortFlag: 'u',
    default: '',
    description: 'Until time - as a unix timestamp'
  }
};

// Internal functions

function setupCommand$c(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...listFullScanFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please specify an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    sort: cli.flags['sort'],
    direction: cli.flags['direction'],
    per_page: cli.flags['perPage'],
    page: cli.flags['page'],
    from_time: cli.flags['fromTime'],
    until_time: cli.flags['untilTime']
  };
}
async function listOrgFullScan(orgSlug, input, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getOrgFullScanList(orgSlug, input), 'Listing scans');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgFullScanList', result, spinner);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: colors.magenta('ID')
    }, {
      field: 'report_url',
      name: colors.magenta('Scan URL')
    }, {
      field: 'branch',
      name: colors.magenta('Branch')
    }, {
      field: 'created_at',
      name: colors.magenta('Created at')
    }]
  };
  const formattedResults = result.data.results.map(d => {
    return {
      id: d.id,
      report_url: colors.underline(`${d.html_report_url}`),
      created_at: d.created_at ? new Date(d.created_at).toLocaleDateString('en-us', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      }) : '',
      branch: d.branch
    };
  });
  spinner.stop(`Listing scans for: ${orgSlug}`);
  console.log(chalkTable(options, formattedResults));
}

const metadata = {
  description: "Get a scan's metadata",
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} metadata`;
    const input = setupCommand$b(name, metadata.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = "Getting scan's metadata... \n";
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await getOrgScanMetadata(input.orgSlug, input.scanID, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$b(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug> <scan id>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 2) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please specify an organization slug and a scan ID.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: scanID = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    scanID
  };
}
async function getOrgScanMetadata(orgSlug, scanId, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getOrgFullScanMetadata(orgSlug, scanId), 'Listing scans');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgFullScanMetadata', result, spinner);
    return;
  }
  spinner.stop('Scan metadata:');
  console.log(result.data);
}

const stream = {
  description: 'Stream the output of a scan',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} stream`;
    const input = setupCommand$a(name, stream.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = yoctoSpinner({
        text: 'Streaming scan...'
      }).start();
      const result = await getOrgFullScan(input.orgSlug, input.fullScanId, input.file, apiKey);
      if (result?.success) {
        spinner.stop(input.file ? `Full scan details written to ${input.file}` : '');
      } else {
        handleUnsuccessfulApiResponse('getOrgFullScan', result, spinner);
      }
    }
  }
};

// Internal functions

function setupCommand$a(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug> <scan ID> <path to output file>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg 000aaaa1-0000-0a0a-00a0-00a0000000a0 ./stream.txt
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 2) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please specify an organization slug and a scan ID.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: fullScanId = '',
    2: file
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    fullScanId,
    file
  };
}
async function getOrgFullScan(orgSlug, fullScanId, file, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  return await handleApiCall(socketSdk.getOrgFullScan(orgSlug, fullScanId, file), 'Streaming a scan');
}

const description$2 = 'Scans related commands';
const scan = {
  description: description$2,
  async run(argv, importMeta, {
    parentName
  }) {
    await meowWithSubcommands({
      create: create$1,
      stream,
      list: list$1,
      del: del$1,
      metadata
    }, {
      argv,
      description: description$2,
      importMeta,
      name: parentName + ' scan'
    });
  }
};

const auditLog = {
  description: 'Look up the audit log for an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' audit-log';
    const input = setupCommand$9(name, auditLog.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = yoctoSpinner({
        text: `Looking up audit log for ${input.orgSlug}\n`
      }).start();
      await fetchOrgAuditLog(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const auditLogFlags = {
  type: {
    type: 'string',
    shortFlag: 't',
    default: '',
    description: 'Type of log event'
  },
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Results per page - default is 30'
  },
  page: {
    type: 'number',
    shortFlag: 'p',
    default: 1,
    description: 'Page number - default is 1'
  }
};

// Internal functions

function setupCommand$9(name, description, argv, importMeta) {
  const flags = {
    ...auditLogFlags,
    ...commonFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (cli.input.length < 1) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    json: outputJson,
    markdown: outputMarkdown,
    page,
    perPage
  } = cli.flags;
  const type = cli.flags['type'];
  const {
    0: orgSlug = ''
  } = cli.input;
  return {
    outputJson,
    outputMarkdown,
    orgSlug,
    type: type && type.charAt(0).toUpperCase() + type.slice(1),
    page,
    per_page: perPage
  };
}
async function fetchOrgAuditLog(orgSlug, input, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getAuditLogEvents(orgSlug, input), `Looking up audit log for ${orgSlug}\n`);
  if (!result.success) {
    handleUnsuccessfulApiResponse('getAuditLogEvents', result, spinner);
    return;
  }
  spinner.stop();
  const data = [];
  const logDetails = {};
  for (const d of result.data.results) {
    const {
      created_at
    } = d;
    if (created_at) {
      const name = `${new Date(created_at).toLocaleDateString('en-us', {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
      })} - ${d.user_email} - ${d.type} - ${d.ip_address} - ${d.user_agent}`;
      data.push({
        name
      }, new prompts.Separator());
      logDetails[name] = JSON.stringify(d.payload);
    }
  }
  console.log(logDetails[await prompts.select({
    message: input.type ? `\n Audit log for: ${orgSlug} with type: ${input.type}\n` : `\n Audit log for: ${orgSlug}\n`,
    choices: data,
    pageSize: 30
  })]);
}

const create = {
  description: 'Create a repository in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} create`;
    const input = setupCommand$8(name, create.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Creating repository... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await createRepo(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const repositoryCreationFlags = {
  repoName: {
    type: 'string',
    shortFlag: 'n',
    default: '',
    description: 'Repository name'
  },
  repoDescription: {
    type: 'string',
    shortFlag: 'd',
    default: '',
    description: 'Repository description'
  },
  homepage: {
    type: 'string',
    shortFlag: 'h',
    default: '',
    description: 'Repository url'
  },
  defaultBranch: {
    type: 'string',
    shortFlag: 'b',
    default: 'main',
    description: 'Repository default branch'
  },
  visibility: {
    type: 'string',
    shortFlag: 'v',
    default: 'private',
    description: 'Repository visibility (Default Private)'
  }
};

// Internal functions

function setupCommand$8(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...repositoryCreationFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg --repoName=test-repo
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    repoName
  } = cli.flags;
  const [orgSlug = ''] = cli.input;
  let showHelp = cli.flags['help'];
  if (!orgSlug) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug.`);
  } else if (!repoName) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Repository name is required.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    name: repoName,
    description: cli.flags['repoDescription'],
    homepage: cli.flags['homepage'],
    default_branch: cli.flags['defaultBranch'],
    visibility: cli.flags['visibility']
  };
}
async function createRepo(orgSlug, input, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.createOrgRepo(orgSlug, input), 'creating repository');
  if (result.success) {
    spinner.success('Repository created successfully');
  } else {
    handleUnsuccessfulApiResponse('createOrgRepo', result, spinner);
  }
}

const del = {
  description: 'Delete a repository in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} del`;
    const input = setupCommand$7(name, del.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Deleting repository... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await deleteRepository(input.orgSlug, input.repoName, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$7(name, description, argv, importMeta) {
  const cli = meow(`
    Usage
      $ ${name} <org slug> <repo slug>

    Examples
      $ ${name} FakeOrg test-repo
  `, {
    argv,
    description,
    importMeta
  });
  const {
    0: orgSlug = '',
    1: repoName = ''
  } = cli.input;
  let showHelp = cli.flags['help'];
  if (!orgSlug || !repoName) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug and repository slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    orgSlug,
    repoName
  };
}
async function deleteRepository(orgSlug, repoName, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.deleteOrgRepo(orgSlug, repoName), 'deleting repository');
  if (result.success) {
    spinner.success('Repository deleted successfully');
  } else {
    handleUnsuccessfulApiResponse('deleteOrgRepo', result, spinner);
  }
}

const list = {
  description: 'List repositories in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} list`;
    const input = setupCommand$6(name, list.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Listing repositories... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await listOrgRepos(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const listRepoFlags = {
  sort: {
    type: 'string',
    shortFlag: 's',
    default: 'created_at',
    description: 'Sorting option'
  },
  direction: {
    type: 'string',
    default: 'desc',
    description: 'Direction option'
  },
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Number of results per page'
  },
  page: {
    type: 'number',
    shortFlag: 'p',
    default: 1,
    description: 'Page number'
  }
};

// Internal functions

function setupCommand$6(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...listRepoFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    sort: cli.flags['sort'],
    direction: cli.flags['direction'],
    page: cli.flags['page'],
    per_page: cli.flags['perPage']
  };
}
async function listOrgRepos(orgSlug, input, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getOrgRepoList(orgSlug, input), 'listing repositories');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgRepoList', result, spinner);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: colors.magenta('ID')
    }, {
      field: 'name',
      name: colors.magenta('Name')
    }, {
      field: 'visibility',
      name: colors.magenta('Visibility')
    }, {
      field: 'default_branch',
      name: colors.magenta('Default branch')
    }, {
      field: 'archived',
      name: colors.magenta('Archived')
    }]
  };
  spinner.stop(chalkTable(options, result.data.results));
}

const update = {
  description: 'Update a repository in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} update`;
    const input = setupCommand$5(name, update.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Updating repository... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await updateRepository(input.orgSlug, input, spinner, apiKey);
    }
  }
};
const repositoryUpdateFlags = {
  repoName: {
    type: 'string',
    shortFlag: 'n',
    default: '',
    description: 'Repository name'
  },
  repoDescription: {
    type: 'string',
    shortFlag: 'd',
    default: '',
    description: 'Repository description'
  },
  homepage: {
    type: 'string',
    shortFlag: 'h',
    default: '',
    description: 'Repository url'
  },
  defaultBranch: {
    type: 'string',
    shortFlag: 'b',
    default: 'main',
    description: 'Repository default branch'
  },
  visibility: {
    type: 'string',
    shortFlag: 'v',
    default: 'private',
    description: 'Repository visibility (Default Private)'
  }
};

// Internal functions

function setupCommand$5(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...repositoryUpdateFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    repoName
  } = cli.flags;
  const [orgSlug = ''] = cli.input;
  let showHelp = cli.flags['help'];
  if (!orgSlug) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug and repository name.`);
  } else if (!repoName) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Repository name is required.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    name: repoName,
    description: cli.flags['repoDescription'],
    homepage: cli.flags['homepage'],
    default_branch: cli.flags['defaultBranch'],
    visibility: cli.flags['visibility']
  };
}
async function updateRepository(orgSlug, input, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.updateOrgRepo(orgSlug, input.name, input), 'updating repository');
  if (result.success) {
    spinner.success('Repository updated successfully');
  } else {
    handleUnsuccessfulApiResponse('updateOrgRepo', result, spinner);
  }
}

const view = {
  description: 'View repositories in an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} view`;
    const input = setupCommand$4(name, view.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Fetching repository... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await viewRepository(input.orgSlug, input.repositoryName, spinner, apiKey);
    }
  }
};

// Internal functions

function setupCommand$4(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeOrg
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  let showHelp = cli.flags['help'];
  if (!cli.input[0]) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug and repository name.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const {
    0: orgSlug = '',
    1: repositoryName = ''
  } = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    orgSlug,
    repositoryName
  };
}
async function viewRepository(orgSlug, repoName, spinner, apiKey) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getOrgRepo(orgSlug, repoName), 'fetching repository');
  if (!result.success) {
    handleUnsuccessfulApiResponse('getOrgRepo', result, spinner);
    return;
  }
  const options = {
    columns: [{
      field: 'id',
      name: colors.magenta('ID')
    }, {
      field: 'name',
      name: colors.magenta('Name')
    }, {
      field: 'visibility',
      name: colors.magenta('Visibility')
    }, {
      field: 'default_branch',
      name: colors.magenta('Default branch')
    }, {
      field: 'homepage',
      name: colors.magenta('Homepage')
    }, {
      field: 'archived',
      name: colors.magenta('Archived')
    }, {
      field: 'created_at',
      name: colors.magenta('Created at')
    }]
  };
  spinner.stop(chalkTable(options, [result.data]));
}

const description$1 = 'Repositories related commands';
const repo = {
  description: description$1,
  run: async (argv, importMeta, {
    parentName
  }) => {
    await meowWithSubcommands({
      create,
      view,
      list,
      del,
      update
    }, {
      argv,
      description: description$1,
      importMeta,
      name: `${parentName} repo`
    });
  }
};

const dependencies = {
  description: 'Search for any dependency that is being used in your organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' dependencies';
    const input = setupCommand$3(name, dependencies.description, argv, importMeta);
    {
      await searchDeps(input);
    }
  }
};
const dependenciesFlags = {
  limit: {
    type: 'number',
    shortFlag: 'l',
    default: 50,
    description: 'Maximum number of dependencies returned'
  },
  offset: {
    type: 'number',
    shortFlag: 'o',
    default: 0,
    description: 'Page number'
  }
};

// Internal functions

function setupCommand$3(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...dependenciesFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name}

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name}
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    json: outputJson,
    limit,
    markdown: outputMarkdown,
    offset
  } = cli.flags;
  return {
    outputJson,
    outputMarkdown,
    limit,
    offset
  };
}
async function searchDeps({
  limit,
  offset,
  outputJson
}) {
  const apiKey = sdk.getDefaultKey();
  if (!apiKey) {
    throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
  }
  const spinner = yoctoSpinner({
    text: 'Searching dependencies...'
  }).start();
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.searchDependencies({
    limit,
    offset
  }), 'Searching dependencies');
  if (!result.success) {
    handleUnsuccessfulApiResponse('searchDependencies', result, spinner);
    return;
  }
  spinner.stop('Organization dependencies:');
  if (outputJson) {
    console.log(result.data);
    return;
  }
  const options = {
    columns: [{
      field: 'namespace',
      name: colors.cyan('Namespace')
    }, {
      field: 'name',
      name: colors.cyan('Name')
    }, {
      field: 'version',
      name: colors.cyan('Version')
    }, {
      field: 'repository',
      name: colors.cyan('Repository')
    }, {
      field: 'branch',
      name: colors.cyan('Branch')
    }, {
      field: 'type',
      name: colors.cyan('Type')
    }, {
      field: 'direct',
      name: colors.cyan('Direct')
    }]
  };
  console.log(chalkTable(options, result.data.rows));
}

const analytics = {
  description: `Look up analytics data \n
  Default parameters are set to show the organization-level analytics over the last 7 days.`,
  async run(argv, importMeta, {
    parentName
  }) {
    const name = parentName + ' analytics';
    const input = setupCommand$2(name, analytics.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = yoctoSpinner({
        text: 'Fetching analytics data'
      }).start();
      if (input.scope === 'org') {
        await fetchOrgAnalyticsData(input.time, spinner, apiKey, input.outputJson, input.file);
      } else {
        if (input.repo) {
          await fetchRepoAnalyticsData(input.repo, input.time, spinner, apiKey, input.outputJson, input.file);
        }
      }
    }
  }
};
const analyticsFlags = {
  scope: {
    type: 'string',
    shortFlag: 's',
    default: 'org',
    description: "Scope of the analytics data - either 'org' or 'repo'"
  },
  time: {
    type: 'number',
    shortFlag: 't',
    default: 7,
    description: 'Time filter - either 7, 30 or 90'
  },
  repo: {
    type: 'string',
    shortFlag: 'r',
    default: '',
    description: 'Name of the repository'
  },
  file: {
    type: 'string',
    shortFlag: 'f',
    default: '',
    description: 'Path to a local file to save the output'
  }
};

// Internal functions

function setupCommand$2(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...analyticsFlags
  };
  const cli = meow(`
    Usage
      $ ${name} --scope=<scope> --time=<time filter>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} --scope=org --time=7
      $ ${name} --scope=org --time=30
      $ ${name} --scope=repo --repo=test-repo --time=30
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    repo,
    scope,
    time
  } = cli.flags;
  if (scope !== 'org' && scope !== 'repo') {
    throw new sdk.InputError("The scope must either be 'org' or 'repo'");
  }
  if (time !== 7 && time !== 30 && time !== 90) {
    throw new sdk.InputError('The time filter must either be 7, 30 or 90');
  }
  let showHelp = cli.flags['help'];
  if (scope === 'repo' && !repo) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide a repository name when using the repository scope.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  return {
    scope,
    time,
    repo,
    outputJson: cli.flags['json'],
    file: cli.flags['file']
  };
}
const METRICS = ['total_critical_alerts', 'total_high_alerts', 'total_medium_alerts', 'total_low_alerts', 'total_critical_added', 'total_medium_added', 'total_low_added', 'total_high_added', 'total_critical_prevented', 'total_high_prevented', 'total_medium_prevented', 'total_low_prevented'];
async function fetchOrgAnalyticsData(time, spinner, apiKey, outputJson, filePath) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getOrgAnalytics(time.toString()), 'fetching analytics data');
  if (result.success === false) {
    return handleUnsuccessfulApiResponse('getOrgAnalytics', result, spinner);
  }
  spinner.stop();
  if (!result.data.length) {
    return console.log('No analytics data is available for this organization yet.');
  }
  const data = formatData(result.data, 'org');
  if (outputJson && !filePath) {
    return console.log(result.data);
  }
  if (filePath) {
    try {
      await fs$1.writeFile(filePath, JSON.stringify(result.data), 'utf8');
      console.log(`Data successfully written to ${filePath}`);
    } catch (e) {
      console.error(e);
    }
    return;
  }
  return displayAnalyticsScreen(data);
}
const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const formatDate = date => {
  return `${months[new Date(date).getMonth()]} ${new Date(date).getDate()}`;
};
const formatData = (data, scope) => {
  let formattedData, sortedTopFiveAlerts;
  if (scope === 'org') {
    const topFiveAlerts = data.map(d => d['top_five_alert_types']);
    const totalTopAlerts = topFiveAlerts.reduce((acc, current) => {
      const alertTypes = Object.keys(current);
      alertTypes.map(type => {
        if (!acc[type]) {
          acc[type] = current[type];
        } else {
          acc[type] += current[type];
        }
        return acc;
      });
      return acc;
    }, {});
    sortedTopFiveAlerts = Object.entries(totalTopAlerts).sort(({
      1: a
    }, {
      1: b
    }) => b - a).slice(0, 5).reduce((r, {
      0: k,
      1: v
    }) => {
      r[k] = v;
      return r;
    }, {});
    const formatData = label => {
      return data.reduce((acc, current) => {
        const date = formatDate(current['created_at']);
        if (!acc[date]) {
          acc[date] = current[label];
        } else {
          acc[date] += current[label];
        }
        return acc;
      }, {});
    };
    formattedData = METRICS.reduce((acc, current) => {
      acc[current] = formatData(current);
      return acc;
    }, {});
  } else if (scope === 'repo') {
    const topAlerts = data.reduce((acc, current) => {
      const alertTypes = Object.keys(current['top_five_alert_types']);
      alertTypes.map(type => {
        if (!acc[type]) {
          acc[type] = current['top_five_alert_types'][type];
        } else {
          if (current['top_five_alert_types'][type] > (acc[type] || 0)) {
            acc[type] = current['top_five_alert_types'][type];
          }
        }
        return acc;
      });
      return acc;
    }, {});
    sortedTopFiveAlerts = Object.entries(topAlerts).sort(({
      1: a
    }, {
      1: b
    }) => b - a).slice(0, 5).reduce((r, {
      0: k,
      1: v
    }) => {
      r[k] = v;
      return r;
    }, {});
    formattedData = data.reduce((acc, current) => {
      METRICS.forEach(m => {
        if (!acc[m]) {
          acc[m] = {};
        }
        acc[m][formatDate(current['created_at'])] = current[m];
        return acc;
      });
      return acc;
    }, {});
  }
  return {
    ...formattedData,
    top_five_alert_types: sortedTopFiveAlerts
  };
};
async function fetchRepoAnalyticsData(repo, time, spinner, apiKey, outputJson, filePath) {
  const socketSdk = await sdk.setupSdk(apiKey);
  const result = await handleApiCall(socketSdk.getRepoAnalytics(repo, time.toString()), 'fetching analytics data');
  if (result.success === false) {
    return handleUnsuccessfulApiResponse('getRepoAnalytics', result, spinner);
  }
  spinner.stop();
  if (!result.data.length) {
    return console.log('No analytics data is available for this organization yet.');
  }
  const data = formatData(result.data, 'repo');
  if (outputJson && !filePath) {
    return console.log(result.data);
  }
  if (filePath) {
    try {
      await fs$1.writeFile(filePath, JSON.stringify(result.data), 'utf8');
      console.log(`Data successfully written to ${filePath}`);
    } catch (e) {
      console.error(e);
    }
    return;
  }
  return displayAnalyticsScreen(data);
}
const displayAnalyticsScreen = data => {
  const screen = new ScreenWidget();
  const grid = new GridLayout({
    rows: 5,
    cols: 4,
    screen
  });
  renderLineCharts(grid, screen, 'Total critical alerts', [0, 0, 1, 2], data['total_critical_alerts']);
  renderLineCharts(grid, screen, 'Total high alerts', [0, 2, 1, 2], data['total_high_alerts']);
  renderLineCharts(grid, screen, 'Total critical alerts added to the main branch', [1, 0, 1, 2], data['total_critical_added']);
  renderLineCharts(grid, screen, 'Total high alerts added to the main branch', [1, 2, 1, 2], data['total_high_added']);
  renderLineCharts(grid, screen, 'Total critical alerts prevented from the main branch', [2, 0, 1, 2], data['total_critical_prevented']);
  renderLineCharts(grid, screen, 'Total high alerts prevented from the main branch', [2, 2, 1, 2], data['total_high_prevented']);
  renderLineCharts(grid, screen, 'Total medium alerts prevented from the main branch', [3, 0, 1, 2], data['total_medium_prevented']);
  renderLineCharts(grid, screen, 'Total low alerts prevented from the main branch', [3, 2, 1, 2], data['total_low_prevented']);
  const bar = grid.set(4, 0, 1, 2, BarChart, {
    label: 'Top 5 alert types',
    barWidth: 10,
    barSpacing: 17,
    xOffset: 0,
    maxHeight: 9,
    barBgColor: 'magenta'
  });
  screen.append(bar); //must append before setting data

  bar.setData({
    titles: Object.keys(data.top_five_alert_types),
    data: Object.values(data.top_five_alert_types)
  });
  screen.render();
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
};
const renderLineCharts = (grid, screen, title, coords, data) => {
  const line = grid.set(...coords, LineChart, {
    style: {
      line: 'cyan',
      text: 'cyan',
      baseline: 'black'
    },
    xLabelPadding: 0,
    xPadding: 0,
    xOffset: 0,
    wholeNumbersOnly: true,
    legend: {
      width: 1
    },
    label: title
  });
  screen.append(line);
  const lineData = {
    x: Object.keys(data),
    y: Object.values(data)
  };
  line.setData([lineData]);
};

const get = {
  description: 'Get a diff scan for an organization',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} get`;
    const input = setupCommand$1(name, get.description, argv, importMeta);
    if (input) {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinnerText = 'Getting diff scan... \n';
      const spinner = yoctoSpinner({
        text: spinnerText
      }).start();
      await getDiffScan(input, spinner, apiKey);
    }
  }
};
const getDiffScanFlags = {
  before: {
    type: 'string',
    shortFlag: 'b',
    default: '',
    description: 'The full scan ID of the base scan'
  },
  after: {
    type: 'string',
    shortFlag: 'a',
    default: '',
    description: 'The full scan ID of the head scan'
  },
  preview: {
    type: 'boolean',
    shortFlag: 'p',
    default: true,
    description: 'A boolean flag to persist or not the diff scan result'
  },
  file: {
    type: 'string',
    shortFlag: 'f',
    default: '',
    description: 'Path to a local file where the output should be saved'
  }
};

// Internal functions

function setupCommand$1(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...getDiffScanFlags,
    ...outputFlags
  };
  const cli = meow(`
    Usage
      $ ${name} <org slug> --before=<before> --after=<after>

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name} FakeCorp --before=aaa0aa0a-aaaa-0000-0a0a-0000000a00a0 --after=aaa1aa1a-aaaa-1111-1a1a-1111111a11a1
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    after,
    before
  } = cli.flags;
  let showHelp = cli.flags['help'];
  if (!before || !after) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please specify a before and after full scan ID. To get full scans IDs, you can run the command "socket scan list <your org slug>".`);
  } else if (cli.input.length < 1) {
    showHelp = true;
    console.error(`${colors.bgRed(colors.white('Input error'))}: Please provide an organization slug.`);
  }
  if (showHelp) {
    cli.showHelp();
    return;
  }
  const [orgSlug = ''] = cli.input;
  return {
    outputJson: cli.flags['json'],
    outputMarkdown: cli.flags['markdown'],
    before,
    after,
    preview: cli.flags['preview'],
    orgSlug,
    file: cli.flags['file']
  };
}
async function getDiffScan({
  after,
  before,
  file,
  orgSlug,
  outputJson
}, spinner, apiKey) {
  const response = await queryAPI(`${orgSlug}/full-scans/diff?before=${before}&after=${after}&preview`, apiKey);
  const data = await response.json();
  if (!response.ok) {
    const err = await handleAPIError(response.status);
    spinner.error(`${colors.bgRed(colors.white(response.statusText))}: ${err}`);
    return;
  }
  spinner.stop();
  if (file && !outputJson) {
    fs.writeFile(file, JSON.stringify(data), err => {
      err ? console.error(err) : console.log(`Data successfully written to ${file}`);
    });
    return;
  }
  if (outputJson) {
    console.log(`\n Diff scan result: \n`);
    console.log(util.inspect(data, {
      showHidden: false,
      depth: null,
      colors: true
    }));
    console.log(`\n View this diff scan in the Socket dashboard: ${colors.cyan(data?.['diff_report_url'])}`);
    return;
  }
  console.log('Diff scan result:');
  console.log(data);
  console.log(`\n 📝 To display the detailed report in the terminal, use the --json flag \n`);
  console.log(`\n View this diff scan in the Socket dashboard: ${colors.cyan(data?.['diff_report_url'])}`);
}

const description = 'Diff scans related commands';
const diffScan = {
  description,
  run: async (argv, importMeta, {
    parentName
  }) => {
    await meowWithSubcommands({
      get
    }, {
      argv,
      description,
      importMeta,
      name: parentName + ' diff-scan'
    });
  }
};

// @ts-ignore
const threatFeed = {
  description: 'Look up the threat feed',
  async run(argv, importMeta, {
    parentName
  }) {
    const name = `${parentName} threat-feed`;
    const input = setupCommand(name, threatFeed.description, argv, importMeta);
    {
      const apiKey = sdk.getDefaultKey();
      if (!apiKey) {
        throw new sdk.AuthError('User must be authenticated to run this command. To log in, run the command `socket login` and enter your API key.');
      }
      const spinner = yoctoSpinner({
        text: 'Looking up the threat feed'
      }).start();
      await fetchThreatFeed(input, spinner, apiKey);
    }
  }
};
const threatFeedFlags = {
  perPage: {
    type: 'number',
    shortFlag: 'pp',
    default: 30,
    description: 'Number of items per page'
  },
  page: {
    type: 'string',
    shortFlag: 'p',
    default: '1',
    description: 'Page token'
  },
  direction: {
    type: 'string',
    shortFlag: 'd',
    default: 'desc',
    description: 'Order asc or desc by the createdAt attribute.'
  },
  filter: {
    type: 'string',
    shortFlag: 'f',
    default: 'mal',
    description: 'Filter what type of threats to return'
  }
};

// Internal functions

function setupCommand(name, description, argv, importMeta) {
  const flags = {
    ...commonFlags,
    ...outputFlags,
    ...threatFeedFlags
  };
  const cli = meow(`
    Usage
      $ ${name}

    Options
      ${printFlagList(flags, 6)}

    Examples
      $ ${name}
      $ ${name} --perPage=5 --page=2 --direction=asc --filter=joke
  `, {
    argv,
    description,
    importMeta,
    flags
  });
  const {
    direction,
    filter,
    json: outputJson,
    markdown: outputMarkdown,
    page,
    perPage: per_page
  } = cli.flags;
  return {
    outputJson,
    outputMarkdown,
    per_page,
    page,
    direction,
    filter
  };
}
async function fetchThreatFeed({
  direction,
  filter,
  outputJson,
  page,
  per_page
}, spinner, apiKey) {
  const formattedQueryParams = formatQueryParams({
    per_page,
    page,
    direction,
    filter
  }).join('&');
  const response = await queryAPI(`threat-feed?${formattedQueryParams}`, apiKey);
  const data = await response.json();
  spinner.stop();
  if (outputJson) {
    console.log(data);
    return;
  }
  const screen = new ScreenWidget();
  const table = new TableWidget({
    keys: 'true',
    fg: 'white',
    selectedFg: 'white',
    selectedBg: 'magenta',
    interactive: 'true',
    label: 'Threat feed',
    width: '100%',
    height: '100%',
    border: {
      type: 'line',
      fg: 'cyan'
    },
    columnSpacing: 3,
    //in chars
    columnWidth: [9, 30, 10, 17, 13, 100] /*in chars*/
  });

  // allow control the table with the keyboard
  table.focus();
  screen.append(table);
  const formattedOutput = formatResults(data.results);
  table.setData({
    headers: ['Ecosystem', 'Name', 'Version', 'Threat type', 'Detected at', 'Details'],
    data: formattedOutput
  });
  screen.render();
  screen.key(['escape', 'q', 'C-c'], () => process.exit(0));
}
const formatResults = data => {
  return data.map(d => {
    const ecosystem = d.purl.split('pkg:')[1].split('/')[0];
    const name = d.purl.split('/')[1].split('@')[0];
    const version = d.purl.split('@')[1];
    const timeStart = new Date(d.createdAt).getMilliseconds();
    const timeEnd = Date.now();
    const diff = getHourDiff(timeStart, timeEnd);
    const hourDiff = diff > 0 ? `${diff} hours ago` : `${getMinDiff(timeStart, timeEnd)} minutes ago`;
    return [ecosystem, decodeURIComponent(name), version, d.threatType, hourDiff, d.locationHtmlUrl];
  });
};
const formatQueryParams = params => Object.entries(params).map(entry => `${entry[0]}=${entry[1]}`);
const getHourDiff = (start, end) => Math.floor((end - start) / 3600000);
const getMinDiff = (start, end) => Math.floor((end - start) / 60000);

var cliCommands = {
  __proto__: null,
  analytics: analytics,
  auditLog: auditLog,
  cdxgen: cdxgen,
  dependencies: dependencies,
  diffScan: diffScan,
  info: info,
  login: login,
  logout: logout,
  npm: npm,
  npx: npx,
  optimize: optimize,
  organizations: organizations,
  rawNpm: rawNpm,
  rawNpx: rawNpx,
  repo: repo,
  report: report,
  scan: scan,
  threatFeed: threatFeed,
  wrapper: wrapper
};

const {
  rootPkgJsonPath
} = constants;
const formattedCliCommands = Object.fromEntries(Object.entries(cliCommands).map(entry => {
  const key = entry[0];
  entry[0] = camelToHyphen(key);
  return entry;
}));
function camelToHyphen(str) {
  return str.replace(/[A-Z]+/g, '-$&').toLowerCase();
}

// TODO: Add autocompletion using https://socket.dev/npm/package/omelette
void (async () => {
  await updateNotifier({
    name: 'socket',
    version: require(rootPkgJsonPath).version,
    ttl: 86_400_000 /* 24 hours in milliseconds */
  });
  try {
    await meowWithSubcommands(formattedCliCommands, {
      aliases: {
        ci: {
          description: 'Alias for "report create --view --strict"',
          argv: ['report', 'create', '--view', '--strict']
        }
      },
      argv: process.argv.slice(2),
      name: 'socket',
      importMeta: {
        url: `${node_url.pathToFileURL(__filename)}`
      }
    });
  } catch (err) {
    let errorBody;
    let errorTitle;
    let errorMessage = '';
    if (err instanceof sdk.AuthError) {
      errorTitle = 'Authentication error';
      errorMessage = err.message;
    } else if (err instanceof sdk.InputError) {
      errorTitle = 'Invalid input';
      errorMessage = err.message;
      errorBody = err.body;
    } else if (err instanceof Error) {
      errorTitle = 'Unexpected error';
      errorMessage = ponyCause.messageWithCauses(err);
      errorBody = ponyCause.stackWithCauses(err);
    } else {
      errorTitle = 'Unexpected error with no details';
    }
    console.error(`${sdk.logSymbols.error} ${colors.bgRed(colors.white(errorTitle + ':'))} ${errorMessage}`);
    if (errorBody) {
      console.error(`\n${errorBody}`);
    }
    process.exit(1);
  }
})();
